"""
Assistant BIM Simple - Version sans d√©pendances externes
Fournit des r√©ponses rapides bas√©es sur l'analyse IFC sans IA complexe
"""

import json
import logging
from typing import Dict, List, Any, Optional
from pathlib import Path
import re
from datetime import datetime

from ifc_analyzer import IFCAnalyzer
from anomaly_detector import IFCAnomalyDetector

logger = logging.getLogger(__name__)

class SimpleBIMAssistant:
    """Assistant BIM simple sans d√©pendances IA externes"""

    def __init__(self):
        """Initialise l'assistant simple"""
        self.ifc_file_path = None
        self.analysis_data = None
        self.anomalies_data = None
        self.conversation_history = []
        self.model_summary = None
        
        # Base de connaissances simple pour les r√©ponses
        self.knowledge_base = {
            "surfaces": {
                "keywords": ["surface", "aire", "m2", "m¬≤", "superficie"],
                "response_template": "La surface totale du b√¢timent est de {total_floor_area} m¬≤. Les murs repr√©sentent {total_wall_area} m¬≤, les fen√™tres {total_window_area} m¬≤ et les portes {total_door_area} m¬≤."
            },
            "etages": {
                "keywords": ["√©tage", "niveau", "storey", "floor"],
                "response_template": "Le b√¢timent compte {total_storeys} √©tage(s). Voici les d√©tails : {storey_details}"
            },
            "espaces": {
                "keywords": ["espace", "pi√®ce", "room", "space"],
                "response_template": "Le b√¢timent contient {total_spaces} espace(s). Types d'espaces identifi√©s : {space_types}"
            },
            "elements": {
                "keywords": ["√©l√©ment", "composant", "element", "mur", "poutre", "colonne"],
                "response_template": "Le mod√®le contient {total_elements} √©l√©ments au total. √âl√©ments structurels : {beams} poutres, {columns} colonnes, {walls} murs."
            },
            "anomalies": {
                "keywords": ["anomalie", "erreur", "probl√®me", "d√©faut"],
                "response_template": "J'ai d√©tect√© {total_anomalies} anomalie(s) dans le mod√®le. Les principales cat√©gories sont : {anomaly_categories}"
            },
            "materiaux": {
                "keywords": ["mat√©riau", "material", "b√©ton", "acier", "bois"],
                "response_template": "Le mod√®le utilise {total_materials} mat√©riau(x) diff√©rent(s). Mat√©riaux principaux : {material_list}"
            }
        }
        
        logger.info("ü§ñ Assistant BIM Simple initialis√© (r√©ponses rapides)")

    def load_ifc_model(self, ifc_file_path: str) -> Dict[str, Any]:
        """Charge et analyse un mod√®le IFC"""
        try:
            self.ifc_file_path = ifc_file_path
            logger.info(f"üìÇ Chargement du mod√®le IFC: {ifc_file_path}")
            
            # Analyser le fichier IFC
            analyzer = IFCAnalyzer(ifc_file_path)
            self.analysis_data = analyzer.generate_full_analysis()
            
            # D√©tecter les anomalies
            try:
                anomaly_detector = IFCAnomalyDetector(ifc_file_path)
                anomalies_list = anomaly_detector.detect_all_anomalies()
                self.anomalies_data = {
                    "total_anomalies": len(anomalies_list),
                    "anomalies": [
                        {
                            "type": anomaly.anomaly_type,
                            "severity": anomaly.severity.value,
                            "description": anomaly.description
                        } for anomaly in anomalies_list[:10]  # Limiter √† 10 pour la performance
                    ]
                }
            except Exception as e:
                logger.warning(f"Erreur d√©tection anomalies: {e}")
                self.anomalies_data = {"total_anomalies": 0, "anomalies": []}
            
            # G√©n√©rer le r√©sum√©
            self.model_summary = self._generate_model_summary()
            
            logger.info("‚úÖ Mod√®le IFC charg√© et analys√© avec succ√®s")
            return self.model_summary
            
        except Exception as e:
            logger.error(f"‚ùå Erreur chargement mod√®le: {e}")
            raise

    def _generate_model_summary(self) -> Dict[str, Any]:
        """G√©n√®re un r√©sum√© du mod√®le charg√©"""
        if not self.analysis_data:
            return {"error": "Aucune donn√©e d'analyse disponible"}
        
        building_metrics = self.analysis_data.get("building_metrics", {})
        project_info = self.analysis_data.get("project_info", {})
        
        return {
            "project_name": project_info.get("project_name", "Projet BIM"),
            "total_elements": project_info.get("total_elements", 0),
            "surfaces": building_metrics.get("surfaces", {}),
            "storeys": building_metrics.get("storeys", {}),
            "spaces": building_metrics.get("spaces", {}),
            "structural_elements": building_metrics.get("structural_elements", {}),
            "materials": building_metrics.get("materials", {}),
            "anomalies_count": self.anomalies_data.get("total_anomalies", 0),
            "analysis_timestamp": datetime.now().isoformat()
        }

    def ask_question(self, question: str) -> str:
        """R√©pond √† une question sur le mod√®le BIM"""
        if not self.analysis_data:
            return "‚ùå Aucun mod√®le IFC n'est charg√©. Veuillez d'abord charger un fichier IFC."
        
        # Ajouter √† l'historique
        self.conversation_history.append({
            "timestamp": datetime.now().isoformat(),
            "question": question,
            "type": "user"
        })
        
        try:
            # Analyser la question et g√©n√©rer une r√©ponse
            response = self._generate_response(question)
            
            # Ajouter la r√©ponse √† l'historique
            self.conversation_history.append({
                "timestamp": datetime.now().isoformat(),
                "response": response,
                "type": "assistant"
            })
            
            return response
            
        except Exception as e:
            error_response = f"‚ùå Erreur lors de la g√©n√©ration de la r√©ponse: {str(e)}"
            self.conversation_history.append({
                "timestamp": datetime.now().isoformat(),
                "response": error_response,
                "type": "error"
            })
            return error_response

    def _generate_response(self, question: str) -> str:
        """G√©n√®re une r√©ponse bas√©e sur la question et les donn√©es d'analyse"""
        question_lower = question.lower()
        
        # Rechercher dans la base de connaissances
        for category, knowledge in self.knowledge_base.items():
            if any(keyword in question_lower for keyword in knowledge["keywords"]):
                return self._format_response(category, knowledge["response_template"])
        
        # Questions g√©n√©rales
        if any(word in question_lower for word in ["r√©sum√©", "summary", "g√©n√©ral", "overview"]):
            return self._generate_general_summary()
        
        if any(word in question_lower for word in ["aide", "help", "que", "what", "comment", "how"]):
            return self._generate_help_response()
        
        # R√©ponse par d√©faut
        return self._generate_default_response(question)

    def _format_response(self, category: str, template: str) -> str:
        """Formate une r√©ponse avec les donn√©es du mod√®le"""
        try:
            building_metrics = self.analysis_data.get("building_metrics", {})
            project_info = self.analysis_data.get("project_info", {})
            
            format_data = {
                # Surfaces
                "total_floor_area": round(building_metrics.get("surfaces", {}).get("total_floor_area", 0)),
                "total_wall_area": round(building_metrics.get("surfaces", {}).get("total_wall_area", 0)),
                "total_window_area": round(building_metrics.get("surfaces", {}).get("total_window_area", 0)),
                "total_door_area": round(building_metrics.get("surfaces", {}).get("total_door_area", 0)),
                
                # √âtages
                "total_storeys": building_metrics.get("storeys", {}).get("total_storeys", 0),
                "storey_details": ", ".join([f"{s['name']} ({s['elevation']:.1f}m)" for s in building_metrics.get("storeys", {}).get("storey_details", [])[:3]]),
                
                # Espaces
                "total_spaces": building_metrics.get("spaces", {}).get("total_spaces", 0),
                "space_types": ", ".join(list(building_metrics.get("spaces", {}).get("space_types", {}).keys())[:5]),
                
                # √âl√©ments
                "total_elements": project_info.get("total_elements", 0),
                "beams": building_metrics.get("structural_elements", {}).get("beams", 0),
                "columns": building_metrics.get("structural_elements", {}).get("columns", 0),
                "walls": building_metrics.get("structural_elements", {}).get("walls", 0),
                
                # Anomalies
                "total_anomalies": self.anomalies_data.get("total_anomalies", 0),
                "anomaly_categories": ", ".join(list(set([a["type"] for a in self.anomalies_data.get("anomalies", [])]))),
                
                # Mat√©riaux
                "total_materials": building_metrics.get("materials", {}).get("total_materials", 0),
                "material_list": ", ".join(list(building_metrics.get("materials", {}).get("material_details", {}).keys())[:5])
            }
            
            return template.format(**format_data)
            
        except Exception as e:
            logger.error(f"Erreur formatage r√©ponse: {e}")
            return f"‚ùå Erreur lors du formatage de la r√©ponse pour {category}"

    def _generate_general_summary(self) -> str:
        """G√©n√®re un r√©sum√© g√©n√©ral du mod√®le"""
        if not self.model_summary:
            return "‚ùå Aucun r√©sum√© disponible"
        
        return f"""üìä **R√©sum√© du Mod√®le BIM**

üèóÔ∏è **Projet:** {self.model_summary.get('project_name', 'Non d√©fini')}
üìê **√âl√©ments totaux:** {self.model_summary.get('total_elements', 0):,}
üè¢ **√âtages:** {self.model_summary.get('storeys', {}).get('total_storeys', 0)}
üè† **Espaces:** {self.model_summary.get('spaces', {}).get('total_spaces', 0)}
üìè **Surface totale:** {round(self.model_summary.get('surfaces', {}).get('total_floor_area', 0)):,} m¬≤
üö® **Anomalies d√©tect√©es:** {self.model_summary.get('anomalies_count', 0)}

üí° Posez-moi des questions sp√©cifiques sur les surfaces, √©tages, espaces, √©l√©ments ou anomalies !"""

    def _generate_help_response(self) -> str:
        """G√©n√®re une r√©ponse d'aide"""
        return """ü§ñ **Assistant BIM - Questions que vous pouvez poser:**

üìê **Surfaces:** "Quelle est la surface totale ?" "Combien de m¬≤ de murs ?"
üè¢ **√âtages:** "Combien d'√©tages ?" "Quels sont les niveaux ?"
üè† **Espaces:** "Combien d'espaces ?" "Quels types de pi√®ces ?"
üîß **√âl√©ments:** "Combien d'√©l√©ments ?" "Nombre de poutres/colonnes ?"
üö® **Anomalies:** "Y a-t-il des probl√®mes ?" "Quelles anomalies ?"
üß± **Mat√©riaux:** "Quels mat√©riaux sont utilis√©s ?"
üìä **R√©sum√©:** "Donne-moi un r√©sum√© g√©n√©ral"

üí° **Astuce:** Posez des questions en fran√ßais, je comprends le contexte BIM !"""

    def _generate_default_response(self, question: str) -> str:
        """G√©n√®re une r√©ponse par d√©faut"""
        return f"""ü§î Je n'ai pas trouv√© d'information sp√©cifique pour: "{question}"

üí° **Suggestions:**
- Demandez des informations sur les surfaces, √©tages, espaces
- Posez des questions sur les √©l√©ments structurels
- Demandez un r√©sum√© g√©n√©ral du mod√®le
- Tapez "aide" pour voir toutes les possibilit√©s

üìä **Donn√©es disponibles:** {len(self.analysis_data)} cat√©gories d'analyse"""

    def get_suggested_questions(self) -> List[str]:
        """Retourne des questions sugg√©r√©es"""
        if not self.analysis_data:
            return ["Chargez d'abord un fichier IFC pour obtenir des suggestions."]
        
        suggestions = [
            "Quelle est la surface totale du b√¢timent ?",
            "Combien d'√©tages compte le b√¢timent ?",
            "Quels types d'espaces sont pr√©sents ?",
            "Y a-t-il des anomalies dans le mod√®le ?",
            "Combien d'√©l√©ments structurels ?",
            "Donne-moi un r√©sum√© g√©n√©ral",
            "Quels mat√©riaux sont utilis√©s ?",
            "Quelle est la hauteur du b√¢timent ?"
        ]
        
        return suggestions

    def get_conversation_history(self) -> List[Dict[str, Any]]:
        """Retourne l'historique de conversation"""
        return self.conversation_history

    def clear_conversation(self):
        """Efface l'historique de conversation"""
        self.conversation_history = []
        logger.info("üßπ Historique de conversation effac√©")

    def get_model_summary(self) -> Dict[str, Any]:
        """Retourne le r√©sum√© du mod√®le"""
        return self.model_summary or {"error": "Aucun mod√®le charg√©"}

    def generate_quick_insights(self) -> List[str]:
        """G√©n√®re des insights rapides sur le mod√®le"""
        if not self.analysis_data:
            return ["Aucun mod√®le charg√©"]
        
        insights = []
        building_metrics = self.analysis_data.get("building_metrics", {})
        
        # Insights sur les surfaces
        surfaces = building_metrics.get("surfaces", {})
        if surfaces.get("total_floor_area", 0) > 1000:
            insights.append(f"üè¢ Grand b√¢timent: {round(surfaces['total_floor_area']):,} m¬≤ de surface")
        
        # Insights sur les √©tages
        storeys = building_metrics.get("storeys", {})
        if storeys.get("total_storeys", 0) > 5:
            insights.append(f"üèóÔ∏è B√¢timent de grande hauteur: {storeys['total_storeys']} √©tages")
        
        # Insights sur les anomalies
        if self.anomalies_data.get("total_anomalies", 0) > 0:
            insights.append(f"‚ö†Ô∏è {self.anomalies_data['total_anomalies']} anomalie(s) d√©tect√©e(s)")
        
        # Insights sur la complexit√©
        total_elements = self.analysis_data.get("project_info", {}).get("total_elements", 0)
        if total_elements > 1000:
            insights.append(f"üîß Mod√®le complexe: {total_elements:,} √©l√©ments")
        
        return insights if insights else ["üìä Mod√®le BIM standard analys√©"]
