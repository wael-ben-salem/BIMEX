<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>xeokit BIM Viewer</title>
    <!-- üîß CORRECTION: Utiliser des chemins absoluts pour √©viter les conflits de port -->
    <!-- üîß CORRECTION FINALE: Utiliser uniquement le CDN FontAwesome pour √©viter tous les conflits -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" type="text/css" />
    <link rel="stylesheet" href="http://localhost:8081/xeokit-bim-viewer/dist/xeokit-bim-viewer.css" type="text/css" />
    <link rel="stylesheet" href="http://localhost:8081/xeokit-bim-viewer/app/css/style.css" type="text/css" />
    <style>
        /* Variables CSS pour les th√®mes */
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-light: #888888;
            --border-color: #e0e0e0;
            --card-bg: rgba(255, 255, 255, 0.95);
            --card-text: #333333;
            --accent-color: #667eea;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --error-color: #f44336;
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --text-light: #999999;
            --border-color: #404040;
            --card-bg: rgba(45, 45, 45, 0.95);
            --card-text: #ffffff;
            --accent-color: #8fa4f3;
            --success-color: #66bb6a;
            --warning-color: #ffb74d;
            --error-color: #ef5350;
        }

        /* Styles uniformes pour TOUS les boutons */
        .xeokit-btn, .explorer_toggle_label, .inspector_toggle_label {
            background-color: #03103F !important;
            color: white !important;
            border: none !important;
            transition: all 0.3s ease;
            font-size: 16px !important; /* Taille uniforme */
            width: auto !important;
            height: auto !important;
            padding: 8px 12px !important;
        }

        /* Th√®me sombre - tous les boutons en noir */
        [data-theme="dark"] .xeokit-btn,
        [data-theme="dark"] .explorer_toggle_label,
        [data-theme="dark"] .inspector_toggle_label {
            background-color: #000000 !important;
            color: white !important;
            border: none !important;
        }

        /* Hover effects uniformes */
        .xeokit-btn:hover,
        .explorer_toggle_label:hover,
        .inspector_toggle_label:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        /* Garder la taille originale pour les toggles Explorer et Properties */
        .explorer_toggle_label, .inspector_toggle_label {
            font-size: 24px !important; /* Garder fa-2x */
            padding: 10px !important;
        }

        /* Styles pour les onglets et l'explorateur selon le th√®me */
        .xeokit-tabs {
            color: white !important;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .xeokit-tabs {
            background-color: #1a1a1a !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color);
        }

        #myExplorer {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] #myExplorer {
            background-color: black !important;
            color: var(--text-primary) !important;
            border: 1px solid var(--border-color);
        }

        /* Styles pour les √©l√©ments de l'explorateur */
        [data-theme="dark"] .xeokit-tree-panel {
            background-color: black !important;
            color: var(--text-primary) !important;
        }

        [data-theme="dark"] .xeokit-tree-panel .xeokit-tree-node {
            color: var(--text-primary) !important;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        /* En-t√™te avec informations du projet */
        .project-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 20px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .project-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .project-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .project-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Bouton de basculement de th√®me */
        .theme-toggle {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .theme-toggle:hover {
            transform: scale(1.05);
        }

        /* Panneau d'informations du mod√®le */
        .model-info-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            min-width: 250px;
            max-width: 300px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .model-info-panel.visible {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .info-label {
            color: var(--text-secondary);
        }

        .info-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Panneau de capture d'√©cran */
        .screenshot-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 999;
        }

        .screenshot-btn {
            background: var(--success-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
            transition: all 0.3s ease;
        }

        .screenshot-btn:hover {
            transform: scale(1.05);
        }

        /* Panneau d'annotations */
        .annotations-panel {
            position: fixed;
            left: 20px;
            bottom: 20px;
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 999;
            max-width: 300px;
        }

        .annotation-item {
            background: var(--bg-secondary);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 3px solid var(--accent-color);
        }

        .annotation-text {
            font-size: 13px;
            color: var(--text-primary);
        }

        .annotation-coords {
            font-size: 11px;
            color: var(--text-light);
            margin-top: 5px;
        }

        /* Ajustement pour l'espace de l'en-t√™te */
        #myViewer {
            margin-top: 60px;
            height: calc(100vh - 60px);
            position: relative;
            z-index: 1;
        }

        /* Assurer que les panneaux sont au-dessus du viewer */
        .model-info-panel, .light-controls-panel, .view-modes-panel, .annotations-panel {
            z-index: 1000;
        }

        /* Overlay de chargement */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            flex-direction: column;
        }

        .loading-spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--text-primary);
            font-size: 18px;
            font-weight: 500;
        }

        /* Styles pour les boutons personnalis√©s dans la barre d'outils */
        .xeokit-theme-toggle.active {
            background-color: var(--accent-color) !important;
            color: white !important;
        }

        .xeokit-model-info.active {
            background-color: var(--success-color) !important;
            color: white !important;
        }

        .xeokit-annotations.active {
            background-color: var(--warning-color) !important;
            color: white !important;
        }

        /* Animation pour les boutons actifs */
        .xeokit-btn.active {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(102, 126, 234, 0); }
            100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0); }
        }

        /* Styles pour le slider d'explosion */
        #explodeSliderContainer {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #explodeSlider {
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #4CAF50 0%, #FF9800 50%, #F44336 100%);
            border-radius: 5px;
            height: 8px;
            outline: none;
            transition: all 0.3s ease;
        }

        #explodeSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #03103F;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        #explodeSlider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        #explodeSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #03103F;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* Animation d'apparition du slider */
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        #explodeSliderContainer {
            animation: slideUp 0.3s ease-out;
        }

        /* Syst√®me de boutons coulissants */
        .sliding-buttons-container {
            position: relative;
            display: flex;
            align-items: center;
            overflow: hidden;
        }

        .sliding-buttons-wrapper {
            display: flex;
            transition: transform 0.4s ease;
            gap: 5px;
        }

        .sliding-buttons-wrapper.hidden {
            transform: translateX(100%);
        }

        .toggle-slide-button.rotated {
            transform: rotate(180deg);
        }

        .toggle-slide-button.rotated:hover {
            transform: rotate(180deg) scale(1.05);
        }

        /* Boutons toujours visibles */
        .always-visible-buttons {
            display: flex;
            gap: 5px;
            margin-right: 10px;
        }

        /* Styles pour les onglets selon le th√®me */
        .xeokit-tab-content {
            background-color: #03103F !important;
            color: white !important;
        }

        [data-theme="dark"] .xeokit-tab-content {
            background-color: #000000 !important;
            color: white !important;
        }







        /* Panneaux de contr√¥les avanc√©s */
        .light-controls-panel {
            position: fixed;
            top: 120px;
            left: 20px;
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            min-width: 280px;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .view-modes-panel {
            position: fixed;
            top: 120px;
            right: 20px;
            background: var(--card-bg);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            min-width: 280px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .light-controls-panel.visible {
            transform: translateX(0) !important;
            opacity: 1 !important;
            visibility: visible !important;
            display: block !important;
        }

        .view-modes-panel.visible {
            transform: translateX(0) !important;
            opacity: 1 !important;
            visibility: visible !important;
            display: block !important;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group h5 {
            margin: 0 0 10px 0;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .control-label {
            color: var(--text-secondary);
            font-size: 12px;
            flex: 1;
        }

        .control-buttons {
            display: flex;
            gap: 5px;
        }

        .control-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            transform: scale(1.1);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .toggle-btn {
            background: var(--text-light);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .toggle-btn.active {
            background: var(--success-color);
        }

        .view-mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .view-mode-btn {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            color: var(--text-primary);
        }

        .view-mode-btn:hover {
            border-color: var(--accent-color);
            transform: scale(1.02);
        }

        .view-mode-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .view-mode-title {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .view-mode-shortcut {
            font-size: 10px;
            opacity: 0.7;
        }

        .annotations-panel {
            opacity: 0;
            visibility: hidden;
        }

        .annotations-panel.visible {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }

        /* Menu d√©roulant pour les boutons suppl√©mentaires */
        .more-tools-menu {
            position: absolute;
            top: calc(100% + 10px);
            right: 0;
            background: var(--card-bg);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            padding: 10px;
            display: none;
            z-index: 1001;
            min-width: 220px;
            border: 1px solid var(--border-color);
        }

        .more-tools-menu.visible {
            display: block;
        }

        .more-tools-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s ease;
            color: var(--text-primary);
            font-size: 14px;
        }

        .more-tools-item:hover {
            background-color: var(--accent-color);
            color: white;
        }

        .more-tools-item i {
            margin-right: 10px;
            width: 20px;
        }

        .more-tools-btn {
            position: relative;
        }

        /* Fl√®che pour indiquer le menu d√©roulant */
        .more-tools-menu::before {
            content: '';
            position: absolute;
            top: -8px;
            right: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid var(--card-bg);
        }

        /* Am√©lioration du loader */
        .loading-overlay {
            background: linear-gradient(135deg, var(--accent-color) 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-progress {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .loading-progress-bar {
            height: 100%;
            background: white;
            border-radius: 3px;
            width: 0%;
            animation: loadingProgress 3s ease-in-out infinite;
        }

        @keyframes loadingProgress {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 100%; }
        }

        .loading-logo {
            font-size: 4em;
            margin-bottom: 20px;
            animation: float 2s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
    </style>
</head>

<body>
    <!-- Overlay de chargement am√©lior√© -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-logo">
                <img src="../images/logo1.png" alt="Logo" style="height: 62px; vertical-align: middle;">
            </div>
            <h2 style="margin: 0 0 10px 0; font-weight: 600;">xeokit BIM Viewer</h2>
            <p style="margin: 0 0 20px 0; opacity: 0.9;">Chargement du mod√®le BIM...</p>
            <div class="loading-progress">
                <div class="loading-progress-bar"></div>
            </div>
            <p style="margin: 0; font-size: 14px; opacity: 0.7;" id="loadingStatus">Initialisation...</p>
        </div>
    </div>

    <!-- En-t√™te avec informations du projet -->
    <div class="project-header">
        <div class="project-info">
            <img src="../images/logo1.png" alt="Logo" style="height: 62px; vertical-align: middle ;">
            <div>
                <div class="project-title" id="projectTitle">Chargement...</div>
                <div class="project-meta" id="projectMeta">Pr√©paration du mod√®le...</div>
            </div>
        </div>
    </div>

    <!-- Panneau d'informations du mod√®le (masqu√© par d√©faut) -->
    <div class="model-info-panel" id="modelInfoPanel">
        <h4 style="margin-top: 0; color: var(--text-primary);">
            <i class="fas fa-chart-bar"></i> Statistiques du mod√®le
        </h4>
        <div class="info-item">
            <span class="info-label">Objets totaux:</span>
            <span class="info-value" id="totalObjects">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Objets visibles:</span>
            <span class="info-value" id="visibleObjects">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Triangles:</span>
            <span class="info-value" id="totalTriangles">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Taille du fichier:</span>
            <span class="info-value" id="fileSize">-</span>
        </div>
        <div class="info-item">
            <span class="info-label">Position cam√©ra:</span>
            <span class="info-value" id="cameraPosition">-</span>
        </div>
    </div>

    <!-- Panneau de contr√¥les de lumi√®re -->
    <div class="light-controls-panel" id="lightControlsPanel">
        <h4 style="margin-top: 0; color: var(--text-primary);">
            <i class="fas fa-sun"></i> Contr√¥les de Lumi√®re
        </h4>

        <div class="control-group">
            <div class="control-item">
                <span class="control-label">Sun Shadows:</span>
                <button class="toggle-btn" id="sunShadowsToggle">Disabled</button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-item">
                <span class="control-label">Intensity:</span>
                <div class="control-buttons">
                    <button class="control-btn" onclick="adjustLightProperty('intensity', -0.1)">-</button>
                    <span id="intensityValue" style="min-width: 40px; text-align: center; font-size: 11px;">1.0</span>
                    <button class="control-btn" onclick="adjustLightProperty('intensity', 0.1)">+</button>
                </div>
            </div>

            <div class="control-item">
                <span class="control-label">Elevation:</span>
                <div class="control-buttons">
                    <button class="control-btn" onclick="adjustLightProperty('elevation', -5)">-</button>
                    <span id="elevationValue" style="min-width: 40px; text-align: center; font-size: 11px;">45¬∞</span>
                    <button class="control-btn" onclick="adjustLightProperty('elevation', 5)">+</button>
                </div>
            </div>

            <div class="control-item">
                <span class="control-label">Azimuth:</span>
                <div class="control-buttons">
                    <button class="control-btn" onclick="adjustLightProperty('azimuth', -5)">-</button>
                    <span id="azimuthValue" style="min-width: 40px; text-align: center; font-size: 11px;">315¬∞</span>
                    <button class="control-btn" onclick="adjustLightProperty('azimuth', 5)">+</button>
                </div>
            </div>

            <div class="control-item">
                <span class="control-label">Indirect:</span>
                <div class="control-buttons">
                    <button class="control-btn" onclick="adjustLightProperty('indirect', -0.1)">-</button>
                    <span id="indirectValue" style="min-width: 40px; text-align: center; font-size: 11px;">0.4</span>
                    <button class="control-btn" onclick="adjustLightProperty('indirect', 0.1)">+</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Panneau des modes de vue -->
    <div class="view-modes-panel" id="viewModesPanel">
        <h4 style="margin-top: 0; color: var(--text-primary);">
            <i class="fas fa-eye"></i> Modes de Vue
        </h4>

        <div class="view-mode-grid">
            <div class="view-mode-btn active" data-mode="rendered" data-value="1" onclick="setViewMode('rendered', 1)">
                <div class="view-mode-title">Rendered</div>
                <div class="view-mode-shortcut">1</div>
            </div>
            <div class="view-mode-btn" data-mode="shaded" data-value="2" onclick="setViewMode('shaded', 2)">
                <div class="view-mode-title">Shaded</div>
                <div class="view-mode-shortcut">2</div>
            </div>
            <div class="view-mode-btn" data-mode="arctic" data-value="3" onclick="setViewMode('arctic', 3)">
                <div class="view-mode-title">Arctic</div>
                <div class="view-mode-shortcut">3</div>
            </div>
            <div class="view-mode-btn" data-mode="solid" data-value="4" onclick="setViewMode('solid', 4)">
                <div class="view-mode-title">Solid</div>
                <div class="view-mode-shortcut">4</div>
            </div>
            <div class="view-mode-btn" data-mode="pen" data-value="5" onclick="setViewMode('pen', 5)">
                <div class="view-mode-title">Pen</div>
                <div class="view-mode-shortcut">5</div>
            </div>
            <div class="view-mode-btn" data-mode="edges" onclick="toggleEdges()">
                <div class="view-mode-title">Edges</div>
                <div class="view-mode-shortcut">Toggle</div>
            </div>
        </div>

        <div class="control-group" style="margin-top: 15px;">
            <h5>Edge Controls</h5>
            <div class="control-item">
                <span class="control-label">Weight:</span>
                <div class="control-buttons">
                    <button class="control-btn" onclick="adjustEdgeWeight(-0.5)">-</button>
                    <span id="edgeWeightValue" style="min-width: 40px; text-align: center; font-size: 11px;">2</span>
                    <button class="control-btn" onclick="adjustEdgeWeight(0.5)">+</button>
                </div>
            </div>
            <div class="control-item">
                <span class="control-label">Color:</span>
                <input type="color" id="edgeColorPicker" value="#000000" onchange="changeEdgeColor(this.value)"
                       style="width: 30px; height: 25px; border: none; border-radius: 3px; cursor: pointer;">
            </div>
        </div>
    </div>

    <!-- Panneau d'annotations -->
    <div class="annotations-panel" id="annotationsPanel" style="display: block; transform: translateX(-100%); transition: transform 0.3s ease;">
        <h4 style="margin-top: 0; color: var(--text-primary);">
            <i class="fas fa-sticky-note"></i> Annotations
        </h4>
        <div id="annotationsList">
            <p style="color: var(--text-secondary); font-size: 12px;">
                Cliquez sur un objet avec Ctrl+Clic pour ajouter une annotation
            </p>
        </div>
    </div>

    <input type="checkbox" id="explorer_toggle" />
    <label for="explorer_toggle" class="xeokit-i18n explorer_toggle_label xeokit-btn fas fa-2x fa-sitemap"
        data-xeokit-i18ntip="toolbar.toggleExplorer" data-tippy-content="Toggle explorer"></label>
    <input type="checkbox" id="inspector_toggle" />
    <label id="inspector_toggle_label" for="inspector_toggle"
        class="xeokit-i18n inspector_toggle_label xeokit-btn fas fa-info-circle fa-2x"
        data-xeokit-i18ntip="toolbar.toggleProperties" data-tippy-content="Toggle properties"></label>
    <div id="myExplorer"></div>
    <div id="myToolbar"></div>
    <div id="myInspector"></div>
    <div id="myViewer">
        <canvas id="myCanvas"></canvas>
        <canvas id="myNavCubeCanvas"></canvas>
    </div>

</body>

<!-- Tooltips libraries -->
<script src="http://localhost:8081/xeokit-bim-viewer/app/lib/popper.js"></script>
<script src="http://localhost:8081/xeokit-bim-viewer/app/lib/tippy.js"></script>

<script type="module">

    import { Server, BIMViewer, LocaleService } from "http://localhost:8081/xeokit-bim-viewer/dist/xeokit-bim-viewer.es.js";

    import { messages as localeMessages } from "../dist/messages.js";

    window.onload = function () {

        const requestParams = getRequestParams();
        const locale = requestParams.locale || "en";
        const projectId = requestParams.projectId;

        if (!projectId) {
            // Rediriger vers la page d'accueil si aucun projet n'est sp√©cifi√©
            window.location.href = 'home.html';
            return;
        }

        const openExplorer = requestParams.openExplorer;
        setExplorerOpen(openExplorer === "true");

        const enableEditModels = (requestParams.enableEditModels === "true");

        const server = new Server({
            dataDir: requestParams.dataDir || "./data"
        });




        // ===== EXPLORER INIT =====
let explorerInitialized = false;

function initExplorer() {
    const explorer = document.getElementById('myExplorer');
    if (!explorer) return;

    // Force l'affichage initial
    explorer.style.display = 'block';
    explorer.style.visibility = 'visible';
    explorer.style.opacity = '1';
    
    // Surveille les changements de contenu
    const observer = new MutationObserver(() => {
        if (!explorerInitialized && explorer.querySelector('.xeokit-tree-panel')) {
            console.log("Explorer content loaded");
            explorerInitialized = true;
            ensureExplorerVisible();
        }
    });
    observer.observe(explorer, { childList: true, subtree: true });
}

function ensureExplorerVisible() {
    const explorer = document.getElementById('myExplorer');
    const treePanel = explorer?.querySelector('.xeokit-tree-panel');
    
    if (!treePanel) return;
    
    console.log("Ensuring explorer visibility");
    treePanel.style.display = 'block';
    treePanel.style.visibility = 'visible';
    treePanel.style.opacity = '1';
    
    
    // Force le recalcul du layout
    void treePanel.offsetHeight;
}

        // ===== BIMVIEWER CONFIG =====
const bimViewer = new BIMViewer(server, {
    localeService: new LocaleService({
        messages: localeMessages,
        locale: locale
    }),
    enableMeasurements: true,
    canvasElement: document.getElementById("myCanvas"),
    keyboardEventsElement: document,
    explorerElement: document.getElementById("myExplorer"),
    toolbarElement: document.getElementById("myToolbar"),
    inspectorElement: document.getElementById("myInspector"),
    navCubeCanvasElement: document.getElementById("myNavCubeCanvas"),
    busyModelBackdropElement: document.getElementById("loadingOverlay"),
    enableEditModels: enableEditModels,
    
    // Nouveaux callbacks
    onExplorerCreated: () => {
        console.log("BIMViewer: Explorer created");
        initExplorer();
    },
    onTabCreated: (tabId) => {
        console.log(`Tab ${tabId} created`);
        if (['objects', 'storeys', 'classes'].includes(tabId)) {
            setTimeout(ensureExplorerVisible, 300);
        }
    }
});



        
        // Variables globales pour les fonctionnalit√©s
        let annotations = [];
        let modelStats = {
            totalObjects: 0,
            visibleObjects: 0,
            totalTriangles: 0,
            fileSize: 0
        };

        // Initialisation des fonctionnalit√©s
        initializeThemeToggle();

        // Test simple pour v√©rifier si le BIM Viewer fonctionne normalement
        console.log('‚úÖ BIM Viewer initialized successfully');
        initializeAnnotations();
        initializeModelStats();
        initializeScreenshots();

        // Nettoyer compl√®tement l'interface au d√©marrage (fonction d√©finie plus tard)
        setTimeout(() => {
            if (typeof cleanInterface === 'function') {
                cleanInterface();
            } else {
                hideAllPanels();
            }
        }, 100);

        // S'assurer que l'interface reste propre apr√®s le chargement
        setTimeout(() => {
            if (typeof cleanInterface === 'function') {
                cleanInterface();
            } else {
                hideAllPanels();
            }
        }, 1000);

        // Nettoyage suppl√©mentaire apr√®s 3 secondes
        setTimeout(() => {
            if (typeof cleanInterface === 'function') {
                cleanInterface();
                console.log('üßπ Final interface cleanup completed');
            } else {
                hideAllPanels();
                console.log('üßπ Basic cleanup completed');
            }
        }, 3000);

        // Ajouter nos boutons personnalis√©s √† la barre d'outils apr√®s sa cr√©ation
        setTimeout(() => {
            updateLoadingStatus('Initialisation de l\'interface...');
            addCustomToolbarButtons();
        }, 100);

        // Simuler les √©tapes de chargement
        setTimeout(() => updateLoadingStatus('Chargement des ressources...'), 500);
        setTimeout(() => updateLoadingStatus('Pr√©paration du mod√®le 3D...'), 1000);

        bimViewer.localeService.on("updated", () => {
            const localizedElements = document.querySelectorAll('.xeokit-i18n');
            localizedElements.forEach((localizedElement) => {
                if (localizedElement.dataset.xeokitI18n) {
                    localizedElement.innerText = bimViewer.localeService.translate(localizedElement.dataset.xeokitI18n);
                }
                if (localizedElement.dataset.xeokitI18ntip) {
                    const translation = bimViewer.localeService.translate(localizedElement.dataset.xeokitI18ntip);
                    if (translation) {
                        localizedElement.dataset.tippyContent = bimViewer.localeService.translate(localizedElement.dataset.xeokitI18ntip);
                    }
                }
                if (localizedElement.dataset.tippyContent) {
                    if (localizedElement._tippy) {
                        localizedElement._tippy.setContent(localizedElement.dataset.tippyContent);
                    } else {
                        tippy(localizedElement, {
                            appendTo: "parent",
                            zIndex: 1000000,
                            allowHTML: true
                        });
                    }
                }
            });
        });

        bimViewer.setConfigs({
            "showSpaces": false, // Default
            "selectedGlowThrough": true,
            "highlightGlowThrough": true,
            "dtxEnabled": true // Enable data texture scene representation for models - may be slow on low-spec GPUs
        });

        bimViewer.on("openExplorer", () => {
            setExplorerOpen(true);
        });

        bimViewer.on("openInspector", () => {
            setInspectorOpen(true);
        });

        bimViewer.on("addModel", (event) => { // "Add" selected in Models tab's context menu
            console.log("addModel: " + JSON.stringify(event, null, "\t"));
        });

        bimViewer.on("editModel", (event) => { // "Edit" selected in Models tab's context menu
            console.log("editModel: " + JSON.stringify(event, null, "\t"));
        });

        bimViewer.on("deleteModel", (event) => { // "Delete" selected in Models tab's context menu
            console.log("deleteModel: " + JSON.stringify(event, null, "\t"));
        });

        const viewerConfigs = requestParams.configs;
        if (viewerConfigs) {
            const configNameVals = viewerConfigs.split(",");
            for (let i = 0, len = configNameVals.length; i < len; i++) {
                const configNameValStr = configNameVals[i];
                const configNameVal = configNameValStr.split(":");
                const configName = configNameVal[0];
                const configVal = configNameVal[1];
                bimViewer.setConfig(configName, configVal);
            }
        }
        function fixObjectsScroll() {
    const objectsTab = document.querySelector('.xeokit-tab[data-tab-id="objects"]');
    if (!objectsTab) return;

    const observer = new MutationObserver(() => {
        const treePanel = objectsTab.querySelector('.xeokit-tree-panel');
        if (treePanel && !treePanel.dataset.scrollFixed) {
            console.log("Applying scroll fix to Objects tab");
            treePanel.style.height = 'calc(100vh - 200px)';
            treePanel.style.overflowY = 'auto';
            treePanel.dataset.scrollFixed = "true";
            
            // Ajouter un padding si n√©cessaire
            treePanel.querySelector('> div').style.paddingBottom = '20px';
        }
    });

    observer.observe(objectsTab, { childList: true, subtree: true });
}

        bimViewer.loadProject(projectId, () => {
                fixObjectsScroll();

            const modelId = requestParams.modelId;
            if (modelId) {
                bimViewer.loadModel(modelId);
            }
            const tab = requestParams.tab;
            if (tab) {
                bimViewer.openTab(tab);
            }
            watchHashParams();
        },
            (errorMsg) => {
                console.error(errorMsg);
            });

        function watchHashParams() {
            let lastHash = "";
            window.setInterval(() => {
                const currentHash = window.location.hash;
                if (currentHash !== lastHash) {
                    parseHashParams();
                    lastHash = currentHash;
                }
            }, 400);
        }
        window.debugScroll = function() {
    const tab = document.querySelector('.xeokit-tab[data-tab-id="objects"]');
    if (!tab) return;

    const elements = [
        tab,
        tab.querySelector('.xeokit-tree-panel'),
        tab.querySelector('.xeokit-tab-content'),
        tab.querySelector('> div')
    ];

    elements.forEach((el, i) => {
        if (!el) return;
        console.log(`Element ${i}:`, {
            offsetHeight: el.offsetHeight,
            scrollHeight: el.scrollHeight,
            clientHeight: el.clientHeight,
            overflow: getComputedStyle(el).overflow,
            display: getComputedStyle(el).display
        });
    });
};

        function parseHashParams() {
            const params = getHashParams();
            const actionsStr = params.actions;
            if (!actionsStr) {
                return;
            }
            const actions = actionsStr.split(",");
            if (actions.length === 0) {
                return;
            }
            for (let i = 0, len = actions.length; i < len; i++) {
                const action = actions[i];
                switch (action) {
                    case "focusObject":
                        const objectId = params.objectId;
                        if (!objectId) {
                            console.error("Param expected for `focusObject` action: 'objectId'");
                            break;
                        }
                        bimViewer.setAllObjectsSelected(false);
                        bimViewer.setObjectsSelected([objectId], true);
                        bimViewer.flyToObject(objectId, () => {
                            // FIXME: Showing objects in tabs involves scrolling the HTML within the tabs - disable until we know how to scroll the correct DOM element. Otherwise, that function works OK

                            // bimViewer.showObjectInObjectsTab(objectId);
                            // bimViewer.showObjectInClassesTab(objectId);
                            // bimViewer.showObjectInStoreysTab(objectId);
                        });
                        break;
                    case "focusObjects":
                        const objectIds = params.objectIds;
                        if (!objectIds) {
                            console.error("Param expected for `focusObjects` action: 'objectIds'");
                            break;
                        }
                        const objectIdArray = objectIds.split(",");
                        bimViewer.setAllObjectsSelected(false);
                        bimViewer.setObjectsSelected(objectIdArray, true);
                        bimViewer.viewFitObjects(objectIdArray, () => {
                        });
                        break;
                    case "clearFocusObjects":
                        bimViewer.setAllObjectsSelected(false);
                        bimViewer.viewFitAll();
                        // TODO: view fit nothing?
                        break;
                    case "openTab":
                        const tabId = params.tabId;
                        if (!tabId) {
                            console.error("Param expected for `openTab` action: 'tabId'");
                            break;
                        }
                        bimViewer.openTab(tabId);
                        break;
                    default:
                        console.error("Action not supported: '" + action + "'");
                        break;
                }
            }
        }

        function setExplorerOpen(explorerOpen) {
            const toggle = document.getElementById("explorer_toggle");
            if (toggle) {
                toggle.checked = explorerOpen;
            }
        }

        function setInspectorOpen(inspectorOpen) {
            const toggle = document.getElementById("inspector_toggle");
            if (toggle) {
                toggle.checked = inspectorOpen;
            }
        }

        function getRequestParams() {
            const vars = {};
            window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, (m, key, value) => {
                vars[key] = value;
            });
            return vars;
        }

        function getHashParams() {
            const hashParams = {};
            let e;
            const a = /\+/g;  // Regex for replacing addition symbol with a space
            const r = /([^&;=]+)=?([^&;]*)/g;
            const d = function (s) {
                return decodeURIComponent(s.replace(a, " "));
            };
            const q = window.location.hash.substring(1);
            while (e = r.exec(q)) {
                hashParams[d(e[1])] = d(e[2]);
            }
            return hashParams;
        }

        // Fonctions pour les nouvelles fonctionnalit√©s

        // 1. Basculement de th√®me sombre/clair
        function initializeThemeToggle() {
            const themeToggle = document.getElementById('themeToggle');
            const currentTheme = localStorage.getItem('theme') || 'light';

            document.documentElement.setAttribute('data-theme', currentTheme);
            updateThemeButton(currentTheme);

            themeToggle.addEventListener('click', () => {
                const newTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                updateThemeButton(newTheme);
            });
        }

        function updateThemeButton(theme) {
            const themeToggle = document.getElementById('themeToggle');
            if (theme === 'dark') {
                themeToggle.innerHTML = '<i class="fas fa-sun"></i> Clair';
            } else {
                themeToggle.innerHTML = '<i class="fas fa-moon"></i> Sombre';
            }
        }

        // 2. Statistiques du mod√®le
        function initializeModelStats() {
            bimViewer.on("modelLoaded", (modelId) => {
                updateModelStats();
                updateProjectInfo();
                document.getElementById('loadingOverlay').style.display = 'none';
            });

            // Mise √† jour des stats en temps r√©el
            bimViewer.viewer.scene.on("rendered", () => {
                updateCameraPosition();
            });
        }

        function updateModelStats() {
            const scene = bimViewer.viewer.scene;
            const models = scene.models;

            let totalObjects = 0;
            let visibleObjects = 0;
            let totalTriangles = 0;

            for (let modelId in models) {
                const model = models[modelId];
                const objects = model.objects;

                for (let objectId in objects) {
                    const object = objects[objectId];
                    totalObjects++;
                    if (object.visible) {
                        visibleObjects++;
                    }
                    if (object.numTriangles) {
                        totalTriangles += object.numTriangles;
                    }
                }
            }

            modelStats = { totalObjects, visibleObjects, totalTriangles };

            document.getElementById('totalObjects').textContent = totalObjects.toLocaleString();
            document.getElementById('visibleObjects').textContent = visibleObjects.toLocaleString();
            document.getElementById('totalTriangles').textContent = totalTriangles.toLocaleString();
        }

        function updateCameraPosition() {
            const camera = bimViewer.viewer.camera;
            const eye = camera.eye;
            const posText = `${eye[0].toFixed(1)}, ${eye[1].toFixed(1)}, ${eye[2].toFixed(1)}`;
            document.getElementById('cameraPosition').textContent = posText;
        }

        function updateProjectInfo() {
            const projectTitle = document.getElementById('projectTitle');
            const projectMeta = document.getElementById('projectMeta');

            projectTitle.textContent = `Projet: ${projectId}`;
            projectMeta.textContent = `${modelStats.totalObjects} objets ‚Ä¢ ${modelStats.totalTriangles.toLocaleString()} triangles`;
        }

        // 3. Capture d'√©cran et export
        function initializeScreenshots() {
            // Configuration pour les captures
        }

        window.takeScreenshot = function() {
            console.log('üì∏ takeScreenshot called - capturing current view state');

            try {
                // Sauvegarder la position actuelle de la cam√©ra
                const camera = bimViewer.viewer.scene.camera;
                const currentCameraState = {
                    eye: [...camera.eye],
                    look: [...camera.look],
                    up: [...camera.up],
                    projection: camera.projection
                };

                console.log('üìç Current camera position saved:', currentCameraState.eye);

                // Capturer imm√©diatement sans bouger la cam√©ra
                setTimeout(() => {
                    try {
                        const canvas = bimViewer.viewer.scene.canvas.canvas;
                        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                        const filename = `${projectId}_screenshot_${timestamp}.png`;

                        // Cr√©er le lien de t√©l√©chargement
                        const link = document.createElement('a');
                        link.download = filename;
                        link.href = canvas.toDataURL('image/png');

                        // D√©clencher le t√©l√©chargement
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);

                        console.log('‚úÖ Screenshot captured successfully:', filename);
                        console.log('üìç Camera position unchanged - captured current view state');

                        // V√©rifier que la cam√©ra n'a pas boug√©
                        const afterCamera = bimViewer.viewer.scene.camera;
                        const positionChanged =
                            Math.abs(afterCamera.eye[0] - currentCameraState.eye[0]) > 0.001 ||
                            Math.abs(afterCamera.eye[1] - currentCameraState.eye[1]) > 0.001 ||
                            Math.abs(afterCamera.eye[2] - currentCameraState.eye[2]) > 0.001;

                        if (positionChanged) {
                            console.warn('‚ö†Ô∏è Camera position changed during screenshot - restoring...');
                            afterCamera.eye = currentCameraState.eye;
                            afterCamera.look = currentCameraState.look;
                            afterCamera.up = currentCameraState.up;
                            console.log('‚úÖ Camera position restored');
                        } else {
                            console.log('‚úÖ Camera position remained stable during screenshot');
                        }

                    } catch (error) {
                        console.error('‚ùå Error during screenshot capture:', error);
                    }
                }, 50); // D√©lai r√©duit pour capture plus rapide

            } catch (error) {
                console.error('‚ùå Error in takeScreenshot:', error);
            }
        };

        // Variables pour l'explosion progressive
        let isSliderVisible = false;
        let originalPositions = new Map();
        let currentExplodeLevel = 0; // 0 = assembl√©, 100 = compl√®tement explos√©
        let explodedInstances = new Map(); // Pour stocker les instances explos√©es (non utilis√© actuellement)
        let explosionMethod = 'visual'; // 'visual' ou 'physical'

        // Fonction pour afficher/masquer le slider d'explosion
        window.toggleExplodeModel = function() {
            console.log('üí• toggleExplodeModel called - TEMPORARILY DISABLED FOR DEBUGGING');
            return; // TEMPORAIREMENT D√âSACTIV√â
            console.log('üí• toggleExplodeModel called - slider visible:', isSliderVisible);

            try {
                // V√©rifier que bimViewer existe
                if (!window.bimViewer) {
                    console.error('‚ùå bimViewer not found');
                    return;
                }

                const viewer = bimViewer.viewer;
                if (!viewer) {
                    console.error('‚ùå viewer not found');
                    return;
                }

                const scene = viewer.scene;

                // Obtenir le premier mod√®le
                const modelIds = Object.keys(scene.models);

                if (modelIds.length === 0) {
                    console.warn('‚ö†Ô∏è No models found in scene');
                    return;
                }

                const sceneModel = scene.models[modelIds[0]];

                if (!isSliderVisible) {
                    // Afficher le slider
                    showExplodeSlider(sceneModel, scene);
                    document.getElementById('explodeButton').className = 'xeokit-i18n xeokit-explode xeokit-btn fa fa-times';
                    document.getElementById('explodeButton').setAttribute('data-tippy-content', 'Fermer le contr√¥le d\'explosion');
                    isSliderVisible = true;
                    console.log('‚úÖ Explode slider shown');
                } else {
                    // Masquer le slider et remettre le mod√®le √† l'√©tat normal
                    hideExplodeSlider(sceneModel, scene);
                    document.getElementById('explodeButton').className = 'xeokit-i18n xeokit-explode xeokit-btn fa fa-expand-arrows-alt';
                    document.getElementById('explodeButton').setAttribute('data-tippy-content', 'D√©composer/Recomposer le mod√®le');
                    isSliderVisible = false;
                    console.log('‚úÖ Explode slider hidden');
                }
            } catch (error) {
                console.error('‚ùå Error in toggleExplodeModel:', error);
                console.error('‚ùå Stack trace:', error.stack);
            }
        };

        // Fonction pour afficher le slider d'explosion
        function showExplodeSlider(sceneModel, scene) {
            console.log('üéõÔ∏è Showing explode slider...');

            // Cr√©er le conteneur du slider s'il n'existe pas
            let sliderContainer = document.getElementById('explodeSliderContainer');
            if (!sliderContainer) {
                sliderContainer = document.createElement('div');
                sliderContainer.id = 'explodeSliderContainer';
                sliderContainer.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(3, 16, 63, 0.95);
                    padding: 20px;
                    border-radius: 10px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                    z-index: 10000;
                    min-width: 300px;
                    text-align: center;
                    color: white;
                    font-family: Arial, sans-serif;
                `;

                sliderContainer.innerHTML = `
                    <div style="margin-bottom: 15px; font-weight: bold; font-size: 16px;">
                        üß© Niveau de D√©composition
                    </div>
                    <div style="margin-bottom: 10px; display: flex; justify-content: space-between; font-size: 12px;">
                        <span>Assembl√©</span>
                        <span>Explos√©</span>
                    </div>
                    <input type="range" id="explodeSlider" min="0" max="100" value="0"
                           style="width: 100%; height: 6px; background: #ddd; outline: none; border-radius: 3px; cursor: pointer;">
                    <div id="explodeValue" style="margin-top: 10px; font-size: 14px; color: #66ccff;">
                        0% - Mod√®le assembl√©
                    </div>
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #444;">
                        <button id="explosionMethodBtn" onclick="toggleExplosionMethod()"
                                style="width: 100%; padding: 8px; background: #03103F; color: white; border: 1px solid #66ccff; border-radius: 4px; cursor: pointer; font-size: 12px; margin-bottom: 8px;">
                            Mode: Visuel
                        </button>
                        <button onclick="resetExplosionState()"
                                style="width: 100%; padding: 6px; background: #ff6600; color: white; border: 1px solid #ff6600; border-radius: 4px; cursor: pointer; font-size: 11px;">
                            üîÑ R√©initialiser
                        </button>
                        <div style="margin-top: 5px; font-size: 11px; color: #999; text-align: center;">
                            Visuel = Effets visuels | Physique = D√©placement r√©el
                        </div>
                    </div>
                `;

                document.body.appendChild(sliderContainer);

                // Ajouter l'√©v√©nement au slider
                const slider = document.getElementById('explodeSlider');
                const valueDisplay = document.getElementById('explodeValue');

                slider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    currentExplodeLevel = value;

                    // Mettre √† jour l'affichage
                    if (value === 0) {
                        valueDisplay.textContent = '0% - Mod√®le assembl√©';
                        // Restaurer l'√©tat normal selon la m√©thode utilis√©e
                        if (explosionMethod === 'physical') {
                            applyPhysicalExplosion(sceneModel, scene, value);
                        } else {
                            restoreNormalState(sceneModel, scene);
                        }
                    } else if (value === 100) {
                        valueDisplay.textContent = '100% - Compl√®tement explos√©';
                        // Appliquer l'explosion maximale
                        if (explosionMethod === 'physical') {
                            applyPhysicalExplosion(sceneModel, scene, value);
                        } else {
                            applyProgressiveExplode(sceneModel, scene, value);
                        }
                    } else {
                        valueDisplay.textContent = `${value}% - Partiellement explos√©`;
                        // Appliquer l'explosion progressive
                        if (explosionMethod === 'physical') {
                            applyPhysicalExplosion(sceneModel, scene, value);
                        } else {
                            applyProgressiveExplode(sceneModel, scene, value);
                        }
                    }
                });
            }

            // Afficher le slider
            sliderContainer.style.display = 'block';

            // Initialiser les positions originales si n√©cessaire
            if (originalPositions.size === 0) {
                initializeOriginalPositions(sceneModel, scene);
            }
        }

        // Fonction pour masquer le slider d'explosion
        function hideExplodeSlider(sceneModel, scene) {
            console.log('üéõÔ∏è Hiding explode slider...');

            const sliderContainer = document.getElementById('explodeSliderContainer');
            if (sliderContainer) {
                sliderContainer.style.display = 'none';
            }

            // Remettre le mod√®le √† l'√©tat normal
            applyProgressiveExplode(sceneModel, scene, 0);
            currentExplodeLevel = 0;

            // R√©initialiser le slider
            const slider = document.getElementById('explodeSlider');
            if (slider) {
                slider.value = 0;
            }

            const valueDisplay = document.getElementById('explodeValue');
            if (valueDisplay) {
                valueDisplay.textContent = '0% - Mod√®le assembl√©';
            }
        }

        // Fonction pour initialiser les positions originales
        function initializeOriginalPositions(sceneModel, scene) {
            console.log('üìç Initializing original positions...');

            // Obtenir tous les objets de la sc√®ne qui appartiennent √† ce mod√®le
            const objects = scene.objects;
            let objectCount = 0;

            // Filtrer les objets qui appartiennent √† ce mod√®le
            Object.keys(objects).forEach(objectId => {
                const object = objects[objectId];
                if (object && object.model === sceneModel && object.aabb) {
                    // Sauvegarder l'√©tat original complet
                    originalPositions.set(objectId, {
                        aabb: [...object.aabb],
                        center: [
                            (object.aabb[0] + object.aabb[3]) / 2,
                            (object.aabb[1] + object.aabb[4]) / 2,
                            (object.aabb[2] + object.aabb[5]) / 2
                        ],
                        originalMatrix: object.matrix ? [...object.matrix] : null,
                        originalPosition: object.position ? [...object.position] : null,
                        originalOffset: object.offset ? [...object.offset] : null,
                        originalOpacity: object.opacity || 1.0,
                        originalColorize: object.colorize ? [...object.colorize] : [1.0, 1.0, 1.0]
                    });
                    objectCount++;
                }
            });

            console.log(`üìç Initialized ${objectCount} object positions`);

            // Essayer d'utiliser l'API de transformation de xeokit
            if (sceneModel.transform) {
                console.log('üîß Model has transform capability');
            }

            // V√©rifier les capacit√©s de transformation des objets
            let transformCapabilities = {
                hasMatrix: 0,
                hasPosition: 0,
                hasOffset: 0,
                hasTransform: 0
            };

            Object.keys(objects).forEach(objectId => {
                const object = objects[objectId];
                if (object && object.model === sceneModel) {
                    if (object.matrix !== undefined) transformCapabilities.hasMatrix++;
                    if (object.position !== undefined) transformCapabilities.hasPosition++;
                    if (object.offset !== undefined) transformCapabilities.hasOffset++;
                    if (object.transform !== undefined) transformCapabilities.hasTransform++;
                }
            });

            console.log('üîß Transform capabilities:', transformCapabilities);
        }

        // Fonction pour appliquer l'explosion progressive avec approche alternative
        function applyProgressiveExplode(sceneModel, scene, level) {
            console.log(`üéØ Applying explosion level: ${level}%`);

            // Si le niveau est 0, utiliser la fonction de restauration
            if (level === 0) {
                restoreNormalState(sceneModel, scene);
                return;
            }

            // Calculer le centre du mod√®le
            const aabb = sceneModel.aabb;
            const modelCenter = aabb ? [
                (aabb[0] + aabb[3]) / 2,
                (aabb[1] + aabb[4]) / 2,
                (aabb[2] + aabb[5]) / 2
            ] : [0, 0, 0];

            const objects = scene.objects;
            const explosionFactor = (level / 100.0) * 20.0; // Facteur d'explosion plus important
            let processedCount = 0;

            // Essayer d'utiliser l'API de transformation du mod√®le entier
            if (sceneModel.transform) {
                console.log('üîß Using model-level transformation');
                try {
                    // Appliquer une transformation au mod√®le entier
                    const scale = 1.0 + (level / 100.0) * 0.5; // L√©g√®re expansion
                    sceneModel.transform.scale = [scale, scale, scale];
                    sceneModel.transform.position = [
                        modelCenter[0] * (level / 100.0) * 0.1,
                        modelCenter[1] * (level / 100.0) * 0.1,
                        modelCenter[2] * (level / 100.0) * 0.1
                    ];
                } catch (e) {
                    console.warn('‚ö†Ô∏è Model transformation failed:', e.message);
                }
            }

            // Appliquer l'explosion √† tous les objets (approche visuelle am√©lior√©e)
            originalPositions.forEach((originalData, objectId) => {
                const object = objects[objectId];

                if (object && originalData) {
                    const objectCenter = originalData.center;

                    // Calculer le vecteur d'explosion
                    const explodeVector = [
                        objectCenter[0] - modelCenter[0],
                        objectCenter[1] - modelCenter[1],
                        objectCenter[2] - modelCenter[2]
                    ];

                    // Calculer la distance
                    const distance = Math.sqrt(
                        explodeVector[0] * explodeVector[0] +
                        explodeVector[1] * explodeVector[1] +
                        explodeVector[2] * explodeVector[2]
                    );

                    if (distance > 0.1) {
                        // Normaliser et appliquer le facteur d'explosion
                        const normalizedVector = [
                            (explodeVector[0] / distance) * explosionFactor,
                            (explodeVector[1] / distance) * explosionFactor,
                            (explodeVector[2] / distance) * explosionFactor
                        ];

                        // Essayer diff√©rentes approches de transformation
                        let transformationApplied = false;

                        // Approche 1: Utiliser l'API de transformation xeokit si disponible
                        if (object.transform) {
                            try {
                                object.transform.position = normalizedVector;
                                transformationApplied = true;
                                console.log(`‚úÖ Applied transform.position to ${objectId}`);
                            } catch (e) {
                                console.warn(`‚ö†Ô∏è transform.position failed for ${objectId}:`, e.message);
                            }
                        }

                        // Approche 2: Modifier la matrice de transformation
                        if (!transformationApplied && object.matrix !== undefined) {
                            try {
                                const translationMatrix = [
                                    1, 0, 0, 0,
                                    0, 1, 0, 0,
                                    0, 0, 1, 0,
                                    normalizedVector[0], normalizedVector[1], normalizedVector[2], 1
                                ];
                                object.matrix = translationMatrix;
                                transformationApplied = true;
                                console.log(`‚úÖ Applied matrix transformation to ${objectId}`);
                            } catch (e) {
                                console.warn(`‚ö†Ô∏è Matrix transformation failed for ${objectId}:`, e.message);
                            }
                        }

                        // Approche 3: Essayer les propri√©t√©s de position directes
                        if (!transformationApplied) {
                            ['position', 'offset', 'translation'].forEach(prop => {
                                if (object[prop] !== undefined) {
                                    try {
                                        object[prop] = normalizedVector;
                                        transformationApplied = true;
                                        console.log(`‚úÖ Applied ${prop} to ${objectId}`);
                                    } catch (e) {
                                        console.warn(`‚ö†Ô∏è ${prop} failed for ${objectId}:`, e.message);
                                    }
                                }
                            });
                        }

                        // Effet visuel pour simuler l'explosion si la transformation physique √©choue
                        const intensity = level / 100.0;
                        const opacity = Math.max(0.6, 1.0 - intensity * 0.3);

                        // Couleur qui change avec la distance du centre
                        const colorShift = Math.min(distance / 10.0, 1.0) * intensity;
                        object.opacity = opacity;
                        object.colorize = [
                            1.0,
                            1.0 - colorShift * 0.2,
                            1.0 - colorShift * 0.4
                        ];

                        processedCount++;

                        // Log d√©taill√© pour les premiers objets
                        if (processedCount <= 5) {
                            console.log(`üîß Object ${objectId}:`, {
                                center: objectCenter,
                                translation: normalizedVector,
                                distance: distance,
                                transformationApplied: transformationApplied,
                                hasTransform: object.transform !== undefined,
                                hasMatrix: object.matrix !== undefined,
                                hasPosition: object.position !== undefined,
                                hasOffset: object.offset !== undefined
                            });
                        }

                    } else {
                        // Objet au centre - restaurer l'√©tat normal
                        object.opacity = 1.0;
                        object.colorize = [1.0, 1.0, 1.0];
                    }
                }
            });

            // Forcer le rendu de la sc√®ne
            scene.needsRedraw = true;
            if (scene.viewer && scene.viewer.needsRedraw) {
                scene.viewer.needsRedraw = true;
            }

            console.log(`üéØ Applied explosion to ${processedCount} objects`);
        }

        // Fonction pour restaurer l'√©tat normal
        function restoreNormalState(sceneModel, scene) {
            console.log('üîÑ Restoring normal state...');

            const objects = scene.objects;
            let restoredCount = 0;

            originalPositions.forEach((originalData, objectId) => {
                const object = objects[objectId];

                if (object && originalData) {
                    // Restaurer toutes les propri√©t√©s originales
                    object.opacity = originalData.originalOpacity;
                    object.colorize = [...originalData.originalColorize];

                    // Restaurer les transformations
                    if (originalData.originalMatrix && object.matrix !== undefined) {
                        object.matrix = [...originalData.originalMatrix];
                    } else if (object.matrix !== undefined) {
                        object.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                    }

                    if (originalData.originalPosition && object.position !== undefined) {
                        object.position = [...originalData.originalPosition];
                    } else if (object.position !== undefined) {
                        object.position = [0, 0, 0];
                    }

                    if (originalData.originalOffset && object.offset !== undefined) {
                        object.offset = [...originalData.originalOffset];
                    } else if (object.offset !== undefined) {
                        object.offset = [0, 0, 0];
                    }

                    restoredCount++;
                }
            });

            // Forcer le rendu
            scene.needsRedraw = true;
            if (scene.viewer && scene.viewer.needsRedraw) {
                scene.viewer.needsRedraw = true;
            }

            console.log(`üîÑ Restored ${restoredCount} objects to normal state`);
        }

        // Fonction pour restaurer seulement les effets d'explosion (sans toucher √† la visibilit√©)
        function restoreExplosionEffects(scene) {
            console.log('üîÑ Restoring explosion effects only...');

            let restoredCount = 0;
            Object.values(scene.objects).forEach(object => {
                if (object) {
                    try {
                        // Restaurer seulement les propri√©t√©s modifi√©es par l'explosion
                        // NE PAS toucher √† visible, selected, highlighted, xrayed
                        object.opacity = 1.0;
                        object.colorize = [1.0, 1.0, 1.0];

                        // Restaurer les transformations d'explosion
                        if (object.scale !== undefined) {
                            object.scale = [1.0, 1.0, 1.0];
                        }
                        if (object.matrix !== undefined) {
                            object.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                        }
                        if (object.position !== undefined) {
                            object.position = [0, 0, 0];
                        }
                        if (object.offset !== undefined) {
                            object.offset = [0, 0, 0];
                        }

                        restoredCount++;
                    } catch (e) {
                        // Ignorer les erreurs pour les objets en lecture seule
                    }
                }
            });

            // Forcer le rendu
            scene.needsRedraw = true;
            if (scene.viewer && scene.viewer.needsRedraw) {
                scene.viewer.needsRedraw = true;
            }

            console.log(`üîÑ Restored explosion effects on ${restoredCount} objects`);
        }

        // Fonction alternative d'explosion physique par transformation directe
        function applyPhysicalExplosion(sceneModel, scene, level) {
            console.log(`üöÄ Applying physical explosion level: ${level}%`);

            if (level === 0) {
                restoreNormalState(sceneModel, scene);
                return;
            }

            // S'assurer que le mod√®le est visible
            sceneModel.visible = true;

            // Calculer le centre du mod√®le
            const aabb = sceneModel.aabb;
            const modelCenter = aabb ? [
                (aabb[0] + aabb[3]) / 2,
                (aabb[1] + aabb[4]) / 2,
                (aabb[2] + aabb[5]) / 2
            ] : [0, 0, 0];

            const objects = scene.objects;
            const explosionFactor = (level / 100.0) * 30.0; // Facteur d'explosion plus important
            let processedCount = 0;
            let successfulTransforms = 0;

            // Appliquer l'explosion √† tous les objets avec approche physique
            originalPositions.forEach((originalData, objectId) => {
                const object = objects[objectId];

                if (object && originalData) {
                    const objectCenter = originalData.center;

                    // Calculer le vecteur d'explosion
                    const explodeVector = [
                        objectCenter[0] - modelCenter[0],
                        objectCenter[1] - modelCenter[1],
                        objectCenter[2] - modelCenter[2]
                    ];

                    // Calculer la distance
                    const distance = Math.sqrt(
                        explodeVector[0] * explodeVector[0] +
                        explodeVector[1] * explodeVector[1] +
                        explodeVector[2] * explodeVector[2]
                    );

                    if (distance > 0.1) {
                        // Normaliser et appliquer le facteur d'explosion
                        const normalizedVector = [
                            (explodeVector[0] / distance) * explosionFactor,
                            (explodeVector[1] / distance) * explosionFactor,
                            (explodeVector[2] / distance) * explosionFactor
                        ];

                        // Essayer diff√©rentes approches de transformation physique
                        let transformationApplied = false;

                        // Approche 1: Utiliser l'API xeokit Entity si disponible
                        try {
                            if (object.entity && object.entity.transform) {
                                object.entity.transform.position = normalizedVector;
                                transformationApplied = true;
                                successfulTransforms++;
                            }
                        } catch (e) {
                            // Ignorer silencieusement
                        }

                        // Approche 2: Modifier directement les propri√©t√©s de l'objet
                        if (!transformationApplied) {
                            try {
                                // Essayer de modifier la g√©om√©trie ou la position
                                if (object.worldMatrix) {
                                    // Cr√©er une nouvelle matrice avec translation
                                    const newMatrix = [...object.worldMatrix];
                                    newMatrix[12] += normalizedVector[0]; // Translation X
                                    newMatrix[13] += normalizedVector[1]; // Translation Y
                                    newMatrix[14] += normalizedVector[2]; // Translation Z
                                    object.worldMatrix = newMatrix;
                                    transformationApplied = true;
                                    successfulTransforms++;
                                }
                            } catch (e) {
                                // Ignorer silencieusement
                            }
                        }

                        // Approche 3: Utiliser les propri√©t√©s de transformation xeokit
                        if (!transformationApplied) {
                            try {
                                ['translate', 'translation', 'offset', 'position'].forEach(prop => {
                                    if (object[prop] !== undefined && !transformationApplied) {
                                        object[prop] = normalizedVector;
                                        transformationApplied = true;
                                        successfulTransforms++;
                                    }
                                });
                            } catch (e) {
                                // Ignorer silencieusement
                            }
                        }

                        // Si aucune transformation physique n'a fonctionn√©, appliquer un effet visuel am√©lior√©
                        if (!transformationApplied) {
                            const intensity = level / 100.0;
                            const opacity = Math.max(0.5, 1.0 - intensity * 0.4);

                            // Effet visuel qui simule le d√©placement
                            const colorShift = Math.min(distance / 15.0, 1.0) * intensity;
                            object.opacity = opacity;
                            object.colorize = [
                                1.0,
                                1.0 - colorShift * 0.3,
                                1.0 - colorShift * 0.6
                            ];

                            // Essayer de modifier l'√©chelle pour simuler la perspective
                            try {
                                if (object.scale !== undefined) {
                                    const scaleEffect = 1.0 - (intensity * 0.2);
                                    object.scale = [scaleEffect, scaleEffect, scaleEffect];
                                }
                            } catch (e) {
                                // Ignorer silencieusement
                            }
                        }

                        processedCount++;

                        // Log d√©taill√© pour les premiers objets
                        if (processedCount <= 5) {
                            console.log(`üîß Object ${objectId}:`, {
                                center: objectCenter,
                                translation: normalizedVector,
                                distance: distance,
                                transformationApplied: transformationApplied,
                                hasEntity: object.entity !== undefined,
                                hasWorldMatrix: object.worldMatrix !== undefined,
                                hasTranslate: object.translate !== undefined,
                                hasPosition: object.position !== undefined
                            });
                        }

                    } else {
                        // Objet au centre - restaurer l'√©tat normal
                        object.opacity = 1.0;
                        object.colorize = [1.0, 1.0, 1.0];
                        if (object.scale !== undefined) {
                            object.scale = [1.0, 1.0, 1.0];
                        }
                    }
                }
            });

            // Forcer le rendu de la sc√®ne
            scene.needsRedraw = true;
            if (scene.viewer && scene.viewer.needsRedraw) {
                scene.viewer.needsRedraw = true;
            }

            console.log(`üöÄ Physical explosion: ${processedCount} objects processed, ${successfulTransforms} successful transforms`);
        }



        // Fonction pour basculer entre les m√©thodes d'explosion
        window.toggleExplosionMethod = function() {
            const btn = document.getElementById('explosionMethodBtn');
            const slider = document.getElementById('explodeSlider');

            if (explosionMethod === 'visual') {
                explosionMethod = 'physical';
                btn.textContent = 'Mode: Physique';
                btn.style.background = '#ff6600';
                console.log('üîÑ Switched to physical explosion method');
            } else {
                explosionMethod = 'visual';
                btn.textContent = 'Mode: Visuel';
                btn.style.background = '#03103F';
                console.log('üîÑ Switched to visual explosion method');
            }

            // R√©appliquer l'explosion avec la nouvelle m√©thode
            const currentLevel = parseInt(slider.value);

            // Obtenir le mod√®le de sc√®ne
            const sceneModel = scene.models[Object.keys(scene.models)[0]];
            if (!sceneModel) {
                console.warn('‚ö†Ô∏è No scene model found');
                return;
            }

            // R√©initialiser d'abord
            restoreNormalState(sceneModel, scene);

            // Appliquer la nouvelle m√©thode si n√©cessaire
            if (currentLevel > 0) {
                if (explosionMethod === 'physical') {
                    applyPhysicalExplosion(sceneModel, scene, currentLevel);
                } else {
                    applyProgressiveExplode(sceneModel, scene, currentLevel);
                }
            }
        }

        // Fonction pour r√©initialiser compl√®tement l'√©tat d'explosion
        window.resetExplosionState = function() {
            console.log('üîÑ Manual explosion reset triggered');

            // R√©initialiser le slider
            const slider = document.getElementById('explodeSlider');
            if (slider) {
                slider.value = 0;
                currentExplodeLevel = 0;
            }

            const valueDisplay = document.getElementById('explodeValue');
            if (valueDisplay) {
                valueDisplay.textContent = '0% - Mod√®le assembl√©';
            }

            // Restaurer l'√©tat normal
            const scene = bimViewer.viewer.scene;
            const sceneModel = scene.models[Object.keys(scene.models)[0]];
            if (sceneModel) {
                if (originalPositions.size > 0) {
                    restoreNormalState(sceneModel, scene);
                } else {
                    restoreExplosionEffects(scene);
                }
            }

            console.log('‚úÖ Explosion state reset complete');
        }

        // Fonction pour exploser le mod√®le (ancienne version - gard√©e pour compatibilit√©)
        function explodeModel(sceneModel, scene) {
            console.log('üí• Exploding model...');
            console.log('üîç SceneModel structure:', sceneModel);

            // Obtenir tous les objets de la sc√®ne qui appartiennent √† ce mod√®le
            const objects = scene.objects;
            const modelObjects = [];

            // Filtrer les objets qui appartiennent √† ce mod√®le
            Object.keys(objects).forEach(objectId => {
                const object = objects[objectId];
                if (object && object.model === sceneModel) {
                    modelObjects.push(object);
                }
            });

            console.log('üîç Found objects in model:', modelObjects.length);

            if (modelObjects.length === 0) {
                console.warn('‚ö†Ô∏è No objects found in model');
                return;
            }

            // Calculer le centre du mod√®le
            const aabb = sceneModel.aabb;
            const center = aabb ? [
                (aabb[0] + aabb[3]) / 2,
                (aabb[1] + aabb[4]) / 2,
                (aabb[2] + aabb[5]) / 2
            ] : [0, 0, 0];

            console.log('üéØ Model center:', center);

            let explodedCount = 0;

            // Parcourir tous les objets du mod√®le
            modelObjects.forEach(object => {
                if (object && object.aabb) {
                    // Sauvegarder l'√©tat original
                    originalPositions.set(object.id, {
                        visible: object.visible,
                        opacity: object.opacity,
                        colorize: object.colorize ? [...object.colorize] : null
                    });

                    // Calculer le centre de l'objet
                    const objectAABB = object.aabb;
                    const objectCenter = [
                        (objectAABB[0] + objectAABB[3]) / 2,
                        (objectAABB[1] + objectAABB[4]) / 2,
                        (objectAABB[2] + objectAABB[5]) / 2
                    ];

                    // Calculer le vecteur d'explosion
                    const explodeVector = [
                        objectCenter[0] - center[0],
                        objectCenter[1] - center[1],
                        objectCenter[2] - center[2]
                    ];

                    // Calculer la distance et normaliser
                    const distance = Math.sqrt(
                        explodeVector[0] * explodeVector[0] +
                        explodeVector[1] * explodeVector[1] +
                        explodeVector[2] * explodeVector[2]
                    );

                    if (distance > 0.1) { // √âviter les objets au centre
                        // Cr√©er un effet visuel d'explosion en modifiant l'opacit√© et la couleur
                        const distanceFromCenter = distance / 50.0; // Normaliser la distance

                        // R√©duire l'opacit√© pour les objets plus √©loign√©s du centre
                        object.opacity = Math.max(0.3, 1.0 - distanceFromCenter * 0.5);

                        // Coloriser les objets selon leur distance du centre
                        const colorIntensity = Math.min(1.0, distanceFromCenter);
                        object.colorize = [
                            1.0,
                            1.0 - colorIntensity * 0.5,
                            1.0 - colorIntensity * 0.8
                        ];

                        explodedCount++;

                        // Log pour debug (seulement les 5 premiers)
                        if (explodedCount <= 5) {
                            console.log(`üîß Object ${object.id}: opacity=${object.opacity.toFixed(2)}, colorize=[${object.colorize.map(c => c.toFixed(2)).join(', ')}]`);
                        }
                    }
                }
            });

            console.log(`‚úÖ Applied explosion effect to ${explodedCount} objects`);
        }

        // Fonction pour recomposer le mod√®le
        function implodeModel(sceneModel, scene) {
            console.log('üîÑ Imploding model...');

            // Obtenir tous les objets de la sc√®ne
            const objects = scene.objects;
            let implodedCount = 0;

            // Restaurer les propri√©t√©s originales
            originalPositions.forEach((originalData, objectId) => {
                const object = objects[objectId];

                if (object && originalData) {
                    // Restaurer les propri√©t√©s originales
                    object.visible = originalData.visible;
                    object.opacity = originalData.opacity;
                    if (originalData.colorize) {
                        object.colorize = [...originalData.colorize];
                    } else {
                        object.colorize = [1.0, 1.0, 1.0]; // Couleur par d√©faut
                    }

                    implodedCount++;

                    // Log pour debug (seulement les 5 premiers)
                    if (implodedCount <= 5) {
                        console.log(`üîß Object ${objectId}: restored to original state`);
                    }
                }
            });

            console.log(`‚úÖ Restored ${implodedCount} objects to original state`);

            // Nettoyer les donn√©es sauvegard√©es
            originalPositions.clear();
        }

        // Fonction alternative pour capturer avec repositionnement automatique (si besoin)
        window.takeScreenshotWithReset = function() {
            console.log('üì∏ takeScreenshotWithReset called - will reset camera position');

            // S'assurer que le mod√®le est visible et repositionner la cam√©ra
            ensureModelVisibility();

            // Attendre que le repositionnement soit termin√©
            setTimeout(() => {
                try {
                    const canvas = bimViewer.viewer.scene.canvas.canvas;
                    const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
                    const filename = `${projectId}_screenshot_reset_${timestamp}.png`;

                    const link = document.createElement('a');
                    link.download = filename;
                    link.href = canvas.toDataURL('image/png');

                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    console.log('‚úÖ Screenshot with reset captured:', filename);
                } catch (error) {
                    console.error('‚ùå Error during screenshot with reset:', error);
                }
            }, 200); // D√©lai plus long pour le repositionnement
        };

        window.exportView = function() {
            const camera = bimViewer.viewer.camera;
            const viewData = {
                projectId: projectId,
                timestamp: new Date().toISOString(),
                camera: {
                    eye: camera.eye,
                    look: camera.look,
                    up: camera.up,
                    projection: camera.projection
                },
                objects: {
                    visible: [],
                    hidden: [],
                    selected: []
                }
            };

            // Collecter les √©tats des objets
            const scene = bimViewer.viewer.scene;
            for (let objectId in scene.objects) {
                const object = scene.objects[objectId];
                if (object.visible) {
                    viewData.objects.visible.push(objectId);
                } else {
                    viewData.objects.hidden.push(objectId);
                }
                if (object.selected) {
                    viewData.objects.selected.push(objectId);
                }
            }

            const blob = new Blob([JSON.stringify(viewData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `${projectId}_view_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };

        // Fonctions pour les nouvelles fonctionnalit√©s

        // 0. Fonction de mise √† jour du statut de chargement
        function updateLoadingStatus(message) {
            const statusElement = document.getElementById('loadingStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }

        // 0.1. Fonction pour masquer tous les panneaux et √©l√©ments parasites
        function hideAllPanels() {
            console.log('üßπ HIDING ALL PANELS AND PARASITIC ELEMENTS üßπ');

            const panels = [
                'modelInfoPanel',
                'lightControlsPanel',
                'viewModesPanel',
                'annotationsPanel'
            ];

            panels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    panel.classList.remove('visible');
                    panel.style.display = 'none';
                    panel.style.opacity = '0';
                    panel.style.visibility = 'hidden';
                    panel.style.zIndex = '-1';
                    if (panelId === 'lightControlsPanel') {
                        panel.style.transform = 'translateX(-100%)';
                    } else if (panelId === 'viewModesPanel' || panelId === 'modelInfoPanel') {
                        panel.style.transform = 'translateX(100%)';
                    } else if (panelId === 'annotationsPanel') {
                        panel.style.transform = 'translateX(-100%)';
                    }
                    console.log(`‚úÖ Hidden panel: ${panelId}`);
                }
            });

            // Masquer tous les √©l√©ments qui pourraient s'afficher automatiquement
            const parasiteSelectors = [
                '.model-info-panel',
                '.light-controls-panel',
                '.view-modes-panel',
                '.annotations-panel',
                '.screenshot-panel',
                '.more-tools-menu',
                '[class*="panel"]',
                '[class*="overlay"]:not(#loadingOverlay)',
                '[class*="popup"]',
                '[class*="modal"]'
            ];

            parasiteSelectors.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(element => {
                    if (element.id !== 'loadingOverlay') {
                        element.style.display = 'none';
                        element.style.opacity = '0';
                        element.style.visibility = 'hidden';
                        element.style.zIndex = '-1';
                        element.classList.remove('visible');
                        console.log(`‚úÖ Hidden parasitic element:`, element.className);
                    }
                });
            });

            // Forcer le masquage de l'en-t√™te si il interf√®re
            const projectHeader = document.querySelector('.project-header');
            if (projectHeader) {
                projectHeader.style.display = 'none';
                console.log('‚úÖ Hidden project header');
            }

            console.log('üéâ All parasitic elements hidden');
        }

        // ===== CLEAN INTERFACE =====
function cleanInterface() {
    console.log("Cleaning interface (preserving explorer)");
    
    // Liste des √©l√©ments √† NE PAS nettoyer
    const preserveElements = [
        '#myExplorer',
        '.xeokit-tab',
        '.xeokit-tab-content',
        '.xeokit-tree-panel'
    ];
    
    // Masquer seulement les √©l√©ments non critiques
    document.querySelectorAll('.model-info-panel, .light-controls-panel, .view-modes-panel')
        .forEach(el => {
            if (!preserveElements.some(sel => el.matches(sel))) {
                el.style.display = 'none';
            }
        });
    
    // Toujours r√©afficher l'explorateur
    ensureExplorerVisible();
}

        // 1. Basculement de th√®me sombre/clair
        function initializeThemeToggle() {
            const currentTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);

            // Supprimer l'ancien en-t√™te s'il existe
            const oldHeader = document.querySelector('.project-header');
            if (oldHeader) {
                oldHeader.style.display = 'none';
            }
        }

        // 2. Statistiques du mod√®le
        function initializeModelStats() {
            bimViewer.on("modelLoaded", (modelId) => {
                updateLoadingStatus('Calcul des statistiques...');
                setTimeout(() => {
                    updateModelStats();
                    updateProjectInfo();
                    loadExistingAnnotations();
                }, 500);
            });

            // Mise √† jour des stats en temps r√©el
            bimViewer.viewer.scene.on("rendered", () => {
                updateCameraPosition();
            });
        }

        function updateModelStats() {
            const scene = bimViewer.viewer.scene;
            const models = scene.models;

            let totalObjects = 0;
            let visibleObjects = 0;
            let totalTriangles = 0;

            for (let modelId in models) {
                const model = models[modelId];
                const objects = model.objects;

                for (let objectId in objects) {
                    const object = objects[objectId];
                    totalObjects++;
                    if (object.visible) {
                        visibleObjects++;
                    }
                    if (object.numTriangles) {
                        totalTriangles += object.numTriangles;
                    }
                }
            }

            modelStats = { totalObjects, visibleObjects, totalTriangles };

            document.getElementById('totalObjects').textContent = totalObjects.toLocaleString();
            document.getElementById('visibleObjects').textContent = visibleObjects.toLocaleString();
            document.getElementById('totalTriangles').textContent = totalTriangles.toLocaleString();

            // Estimation de la taille du fichier
            const estimatedSize = (totalTriangles * 36) / (1024 * 1024); // Estimation approximative en MB
            document.getElementById('fileSize').textContent = estimatedSize.toFixed(1) + ' MB';
        }

        function updateCameraPosition() {
            const camera = bimViewer.viewer.camera;
            const eye = camera.eye;
            const posText = `${eye[0].toFixed(1)}, ${eye[1].toFixed(1)}, ${eye[2].toFixed(1)}`;
            document.getElementById('cameraPosition').textContent = posText;
        }

        function updateProjectInfo() {
            const projectTitle = document.getElementById('projectTitle');
            const projectMeta = document.getElementById('projectMeta');

            projectTitle.textContent = `Projet: ${projectId}`;
            projectMeta.textContent = `${modelStats.totalObjects} objets ‚Ä¢ ${modelStats.totalTriangles.toLocaleString()} triangles`;
        }



        window.exportView = function() {
            const camera = bimViewer.viewer.camera;
            const viewData = {
                projectId: projectId,
                timestamp: new Date().toISOString(),
                camera: {
                    eye: camera.eye,
                    look: camera.look,
                    up: camera.up,
                    projection: camera.projection
                },
                objects: {
                    visible: [],
                    hidden: [],
                    selected: []
                }
            };

            // Collecter les √©tats des objets
            const scene = bimViewer.viewer.scene;
            for (let objectId in scene.objects) {
                const object = scene.objects[objectId];
                if (object.visible) {
                    viewData.objects.visible.push(objectId);
                } else {
                    viewData.objects.hidden.push(objectId);
                }
                if (object.selected) {
                    viewData.objects.selected.push(objectId);
                }
            }

            const blob = new Blob([JSON.stringify(viewData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `${projectId}_view_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };

        // 4. Syst√®me d'annotations
        function initializeAnnotations() {
            bimViewer.viewer.cameraControl.on("picked", (hit) => {
                if (hit.entity && hit.entity.isObject) {
                    // V√©rifier si Ctrl est press√© pour ajouter une annotation
                    if (window.ctrlPressed) {
                        addAnnotation(hit.entity, hit.worldPos);
                    }
                }
            });

            // D√©tecter les touches Ctrl
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey) {
                    window.ctrlPressed = true;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (!e.ctrlKey) {
                    window.ctrlPressed = false;
                }
            });
        }

        function addAnnotation(entity, worldPos) {
            const annotationText = prompt('Entrez votre annotation:');
            if (annotationText && annotationText.trim()) {
                const annotation = {
                    id: 'annotation_' + Date.now(),
                    text: annotationText.trim(),
                    objectId: entity.id,
                    worldPos: worldPos,
                    timestamp: new Date().toISOString()
                };

                annotations.push(annotation);
                displayAnnotation(annotation);

                // Sauvegarder dans localStorage
                localStorage.setItem(`annotations_${projectId}`, JSON.stringify(annotations));
            }
        }

        function displayAnnotation(annotation) {
            const annotationsList = document.getElementById('annotationsList');

            // Supprimer le message d'aide s'il existe
            const helpText = annotationsList.querySelector('p');
            if (helpText) {
                helpText.remove();
            }

            const annotationDiv = document.createElement('div');
            annotationDiv.className = 'annotation-item';
            annotationDiv.innerHTML = `
                <div class="annotation-text">${annotation.text}</div>
                <div class="annotation-coords">
                    Objet: ${annotation.objectId}<br>
                    Position: ${annotation.worldPos[0].toFixed(2)}, ${annotation.worldPos[1].toFixed(2)}, ${annotation.worldPos[2].toFixed(2)}
                </div>
                <button onclick="removeAnnotation('${annotation.id}')" style="
                    background: var(--error-color);
                    color: white;
                    border: none;
                    border-radius: 3px;
                    padding: 5px 8px;
                    font-size: 11px;
                    cursor: pointer;
                    margin-top: 5px;
                ">Supprimer</button>
            `;

            annotationsList.appendChild(annotationDiv);
        }

        window.removeAnnotation = function(annotationId) {
            annotations = annotations.filter(a => a.id !== annotationId);
            localStorage.setItem(`annotations_${projectId}`, JSON.stringify(annotations));

            // Recharger l'affichage des annotations
            const annotationsList = document.getElementById('annotationsList');
            annotationsList.innerHTML = '';

            if (annotations.length === 0) {
                annotationsList.innerHTML = `
                    <p style="color: var(--text-secondary); font-size: 12px;">
                        Cliquez sur un objet avec Ctrl+Clic pour ajouter une annotation
                    </p>
                `;
            } else {
                annotations.forEach(annotation => displayAnnotation(annotation));
            }
        };

        // Charger les annotations existantes
        function loadExistingAnnotations() {
            const savedAnnotations = localStorage.getItem(`annotations_${projectId}`);
            if (savedAnnotations) {
                annotations = JSON.parse(savedAnnotations);
                annotations.forEach(annotation => displayAnnotation(annotation));
            }
        }

        // 5. Fonction pour basculer le panneau d'informations
        window.toggleModelInfo = function() {
            console.log('toggleModelInfo called');
            const panel = document.getElementById('modelInfoPanel');
            const button = document.querySelector('.xeokit-model-info');

            if (panel) {
                const isVisible = panel.classList.contains('visible');

                if (isVisible) {
                    // Masquer le panneau
                    panel.classList.remove('visible');
                    panel.style.display = 'none';
                    panel.style.opacity = '0';
                    panel.style.visibility = 'hidden';
                    panel.style.transform = 'translateX(100%)';
                } else {
                    // Afficher le panneau
                    panel.classList.add('visible');
                    panel.style.display = 'block';
                    panel.style.opacity = '1';
                    panel.style.visibility = 'visible';
                    panel.style.transform = 'translateX(0)';
                    panel.style.zIndex = '1000';
                }

                console.log('Model info panel visibility:', !isVisible);
            }
            if (button) {
                button.classList.toggle('active');
            }

            // S'assurer que le mod√®le reste visible
            ensureModelVisibility();
        };

        // 6. Fonction pour basculer le panneau d'annotations
        window.toggleAnnotations = function() {
            console.log('toggleAnnotations called');
            const panel = document.getElementById('annotationsPanel');
            const button = document.querySelector('.xeokit-annotations');

            if (panel) {
                const isVisible = panel.classList.contains('visible');

                if (isVisible) {
                    // Masquer le panneau
                    panel.classList.remove('visible');
                    panel.style.display = 'none';
                    panel.style.opacity = '0';
                    panel.style.visibility = 'hidden';
                    panel.style.transform = 'translateX(-100%)';
                } else {
                    // Afficher le panneau
                    panel.classList.add('visible');
                    panel.style.display = 'block';
                    panel.style.opacity = '1';
                    panel.style.visibility = 'visible';
                    panel.style.transform = 'translateX(0)';
                    panel.style.zIndex = '1000';
                }

                console.log('Annotations panel visibility:', !isVisible);
            }
            if (button) {
                button.classList.toggle('active');
            }

            // S'assurer que le mod√®le reste visible
            ensureModelVisibility();
        };

        // 7. Fonction pour basculer les contr√¥les de lumi√®re
        window.toggleLightControls = function() {
            console.log('üîÜ toggleLightControls called');
            const panel = document.getElementById('lightControlsPanel');
            const button = document.querySelector('.xeokit-light-controls');

            if (panel) {
                const isVisible = panel.classList.contains('visible');
                console.log('üîÜ Current visibility state:', isVisible);

                if (isVisible) {
                    // Masquer le panneau
                    console.log('üîÜ Hiding light controls panel');
                    panel.classList.remove('visible');
                    panel.style.display = 'none';
                    panel.style.opacity = '0';
                    panel.style.visibility = 'hidden';
                    panel.style.transform = 'translateX(-100%)';
                    panel.style.zIndex = '-1';
                } else {
                    // Afficher le panneau
                    console.log('üîÜ Showing light controls panel');
                    panel.classList.add('visible');
                    panel.style.display = 'block';
                    panel.style.opacity = '1';
                    panel.style.visibility = 'visible';
                    panel.style.transform = 'translateX(0)';
                    panel.style.zIndex = '1000';
                    panel.style.position = 'fixed';
                    panel.style.top = '120px';
                    panel.style.left = '20px';
                }

                console.log('üîÜ Light controls panel new visibility:', !isVisible);
            } else {
                console.error('üîÜ Light controls panel not found!');
            }

            if (button) {
                button.classList.toggle('active');
                console.log('üîÜ Button active state:', button.classList.contains('active'));
            } else {
                console.error('üîÜ Light controls button not found!');
            }

            // S'assurer que le mod√®le reste visible
            ensureModelVisibility();
        };

        // 8. Fonction pour basculer les modes de vue
        window.toggleViewModes = function() {
            console.log('üé® toggleViewModes called');
            const panel = document.getElementById('viewModesPanel');
            const button = document.querySelector('.xeokit-view-modes');

            if (panel) {
                const isVisible = panel.classList.contains('visible');
                console.log('üé® Current visibility state:', isVisible);

                if (isVisible) {
                    // Masquer le panneau
                    console.log('üé® Hiding view modes panel');
                    panel.classList.remove('visible');
                    panel.style.display = 'none';
                    panel.style.opacity = '0';
                    panel.style.visibility = 'hidden';
                    panel.style.transform = 'translateX(100%)';
                    panel.style.zIndex = '-1';
                } else {
                    // Afficher le panneau
                    console.log('üé® Showing view modes panel');
                    panel.classList.add('visible');
                    panel.style.display = 'block';
                    panel.style.opacity = '1';
                    panel.style.visibility = 'visible';
                    panel.style.transform = 'translateX(0)';
                    panel.style.zIndex = '1000';
                    panel.style.position = 'fixed';
                    panel.style.top = '120px';
                    panel.style.right = '20px';
                }

                console.log('üé® View modes panel new visibility:', !isVisible);
            } else {
                console.error('üé® View modes panel not found!');
            }

            if (button) {
                button.classList.toggle('active');
                console.log('üé® Button active state:', button.classList.contains('active'));
            } else {
                console.error('üé® View modes button not found!');
            }

            // S'assurer que le mod√®le reste visible
            ensureModelVisibility();
        };

        // 9. Fonction pour exporter la vue actuelle
        window.exportView = function() {
            console.log('exportView called');

            if (!bimViewer || !bimViewer.viewer) {
                console.error('BIM Viewer not available');
                return;
            }

            try {
                // Obtenir l'√©tat actuel de la cam√©ra
                const camera = bimViewer.viewer.camera;
                const viewState = {
                    eye: Array.from(camera.eye),
                    look: Array.from(camera.look),
                    up: Array.from(camera.up),
                    projection: camera.projection,
                    timestamp: new Date().toISOString(),
                    projectId: projectId
                };

                // Cr√©er le fichier JSON
                const dataStr = JSON.stringify(viewState, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});

                // T√©l√©charger le fichier
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `${projectId}_view_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
                link.click();

                console.log('‚úÖ View exported successfully');
                console.log('View state:', viewState);

            } catch (e) {
                console.error('‚ùå Error exporting view:', e);
            }
        };



        // 9.1. Fonction pour s'assurer que le mod√®le reste visible
        function ensureModelVisibility() {
            if (bimViewer && bimViewer.viewer && bimViewer.viewer.scene) {
                const scene = bimViewer.viewer.scene;
                let hiddenObjects = 0;
                let hiddenModels = 0;

                // S'assurer que tous les objets du mod√®le restent visibles
                Object.values(scene.objects).forEach(object => {
                    if (object.visible === false) {
                        console.log('Restoring visibility for object:', object.id);
                        object.visible = true;
                        hiddenObjects++;
                    }
                });

                // S'assurer que les mod√®les restent visibles
                Object.values(scene.models).forEach(model => {
                    if (model.visible === false) {
                        console.log('Restoring visibility for model:', model.id);
                        model.visible = true;
                        hiddenModels++;
                    }
                });

                if (hiddenObjects > 0 || hiddenModels > 0) {
                    console.log(`Restored visibility: ${hiddenObjects} objects, ${hiddenModels} models`);
                }

                // R√©initialiser la cam√©ra pour voir le mod√®le
                resetCameraToModel();

                console.log('Model visibility ensured - Total objects:', Object.keys(scene.objects).length, 'Total models:', Object.keys(scene.models).length);
            } else {
                console.warn('BIM Viewer not ready for visibility check');
            }
        }

        // 9.1.1. Fonction pour r√©initialiser la cam√©ra
        function resetCameraToModel() {
            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.scene) {
                    const scene = bimViewer.viewer.scene;

                    // Obtenir la bo√Æte englobante de tous les objets visibles
                    const aabb = scene.getAABB();

                    if (aabb) {
                        console.log('Model AABB:', aabb);

                        // Voler vers le mod√®le
                        bimViewer.viewer.cameraFlight.flyTo({
                            aabb: aabb,
                            duration: 0.5
                        });

                        console.log('Camera reset to model bounds');
                    } else {
                        console.warn('No AABB available for model');

                        // Position de cam√©ra par d√©faut
                        bimViewer.viewer.camera.eye = [50, 50, 50];
                        bimViewer.viewer.camera.look = [0, 0, 0];
                        bimViewer.viewer.camera.up = [0, 1, 0];

                        console.log('Set default camera position');
                    }
                }
            } catch (e) {
                console.error('Error resetting camera:', e);
            }
        }

        // 9.2. Fonction de diagnostic pour v√©rifier l'√©tat du mod√®le
        window.diagnoseModelVisibility = function() {
            console.log('=== MODEL VISIBILITY DIAGNOSIS ===');

            if (!bimViewer) {
                console.error('BIM Viewer not initialized');
                return null;
            }

            if (!bimViewer.viewer) {
                console.error('Viewer not available');
                return null;
            }

            if (!bimViewer.viewer.scene) {
                console.error('Scene not available');
                return null;
            }

            const scene = bimViewer.viewer.scene;
            console.log('BIM Viewer status: OK');
            console.log('Scene status: OK');
            console.log('Total models:', Object.keys(scene.models).length);
            console.log('Total objects:', Object.keys(scene.objects).length);

            if (Object.keys(scene.models).length === 0) {
                console.warn('‚ö†Ô∏è NO MODELS LOADED! This is likely the problem.');
                console.log('Check if the model file exists: app/data/projects/Test1/models/model/design/geometry.xkt');
                return { error: 'No models loaded' };
            }

            if (Object.keys(scene.objects).length === 0) {
                console.warn('‚ö†Ô∏è NO OBJECTS IN SCENE! Model may not have loaded properly.');
                return { error: 'No objects in scene' };
            }

            let visibleObjects = 0;
            let hiddenObjects = 0;
            let visibleModels = 0;
            let hiddenModels = 0;

            Object.values(scene.objects).forEach(object => {
                if (object.visible) {
                    visibleObjects++;
                } else {
                    hiddenObjects++;
                    console.log('Hidden object:', object.id);
                }
            });

            Object.values(scene.models).forEach(model => {
                if (model.visible) {
                    visibleModels++;
                } else {
                    hiddenModels++;
                    console.log('Hidden model:', model.id);
                }
            });

            console.log('‚úÖ Visible models:', visibleModels);
            console.log('‚ùå Hidden models:', hiddenModels);
            console.log('‚úÖ Visible objects:', visibleObjects);
            console.log('‚ùå Hidden objects:', hiddenObjects);

            if (visibleObjects === 0) {
                console.error('üö® ALL OBJECTS ARE HIDDEN! This is the problem.');
                console.log('Try running: ensureModelVisibility()');
            }

            console.log('=== END DIAGNOSIS ===');

            return {
                totalModels: Object.keys(scene.models).length,
                totalObjects: Object.keys(scene.objects).length,
                visibleObjects: visibleObjects,
                hiddenObjects: hiddenObjects,
                visibleModels: visibleModels,
                hiddenModels: hiddenModels
            };
        };

        // 7. Ajouter les boutons personnalis√©s √† la barre d'outils
        function addCustomToolbarButtons() {
            const toolbar = document.querySelector('.xeokit-toolbar');
            if (!toolbar) {
                console.warn('Barre d\'outils non trouv√©e');
                return;
            }

            // Cr√©er un nouveau groupe de boutons avec syst√®me coulissant
            const customButtonGroup = document.createElement('div');
            customButtonGroup.className = 'xeokit-btn-group sliding-buttons-container';
            customButtonGroup.setAttribute('role', 'group');

            // Conteneur pour les boutons toujours visibles
            const alwaysVisibleContainer = document.createElement('div');
            alwaysVisibleContainer.className = 'always-visible-buttons';

            // Conteneur pour les boutons coulissants
            const slidingContainer = document.createElement('div');
            slidingContainer.className = 'sliding-buttons-wrapper';
            slidingContainer.id = 'slidingButtonsWrapper';

            // Bouton de basculement de th√®me (toujours visible)
            const themeButton = document.createElement('button');
            themeButton.type = 'button';
            themeButton.className = 'xeokit-i18n xeokit-theme-toggle xeokit-btn fa fa-moon';
            themeButton.setAttribute('data-tippy-content', 'Basculer le th√®me sombre/clair');
            themeButton.id = 'toolbarThemeToggle';
            themeButton.addEventListener('click', toggleTheme);

            // Bouton de capture d'√©cran (toujours visible)
            const screenshotButton = document.createElement('button');
            screenshotButton.type = 'button';
            screenshotButton.className = 'xeokit-i18n xeokit-screenshot xeokit-btn fa fa-camera';
            screenshotButton.setAttribute('data-tippy-content', 'Prendre une capture d\'√©cran');
            screenshotButton.addEventListener('click', takeScreenshot);

            // Bouton Explode/Implode (toujours visible)
            const explodeButton = document.createElement('button');
            explodeButton.type = 'button';
            explodeButton.className = 'xeokit-i18n xeokit-explode xeokit-btn fa fa-expand-arrows-alt';
            explodeButton.setAttribute('data-tippy-content', 'D√©composer/Recomposer le mod√®le');
            explodeButton.id = 'explodeButton';
            explodeButton.addEventListener('click', function() {
                console.log('üîò Explode button clicked!');
                toggleExplodeModel();
            });

            // Bouton toggle pour afficher/masquer les autres boutons
            const toggleSlideButton = document.createElement('button');
            toggleSlideButton.type = 'button';
            toggleSlideButton.className = 'xeokit-i18n toggle-slide-button xeokit-btn fa fa-chevron-left';
            toggleSlideButton.setAttribute('data-tippy-content', 'Afficher/Masquer plus d\'options');
            toggleSlideButton.id = 'toggleSlideButton';

            let buttonsVisible = false;
            toggleSlideButton.addEventListener('click', function() {
                const wrapper = document.getElementById('slidingButtonsWrapper');
                if (buttonsVisible) {
                    // Masquer les boutons
                    wrapper.classList.add('hidden');
                    this.classList.remove('rotated');
                    this.setAttribute('data-tippy-content', 'Afficher plus d\'options');
                    console.log('üîΩ Boutons masqu√©s');
                } else {
                    // Afficher les boutons
                    wrapper.classList.remove('hidden');
                    this.classList.add('rotated');
                    this.setAttribute('data-tippy-content', 'Masquer les options');
                    console.log('üîº Boutons affich√©s');
                }
                buttonsVisible = !buttonsVisible;
            });

            // Bouton d'informations du mod√®le (coulissant)
            const infoButton = document.createElement('button');
            infoButton.type = 'button';
            infoButton.className = 'xeokit-i18n xeokit-model-info xeokit-btn fa fa-info-circle';
            infoButton.setAttribute('data-tippy-content', 'Afficher les informations du mod√®le');
            infoButton.addEventListener('click', toggleModelInfo);

            // Bouton d'export de vue (coulissant)
            const exportButton = document.createElement('button');
            exportButton.type = 'button';
            exportButton.className = 'xeokit-i18n xeokit-export-view xeokit-btn fa fa-download';
            exportButton.setAttribute('data-tippy-content', 'Exporter la vue actuelle');
            exportButton.addEventListener('click', exportView);

            // Bouton d'annotations (coulissant)
            const annotationButton = document.createElement('button');
            annotationButton.type = 'button';
            annotationButton.className = 'xeokit-i18n xeokit-annotations xeokit-btn fa fa-sticky-note';
            annotationButton.setAttribute('data-tippy-content', 'Basculer le panneau d\'annotations');
            annotationButton.addEventListener('click', toggleAnnotations);

            // Bouton de contr√¥les de lumi√®re
            const lightControlsButton = document.createElement('button');
            lightControlsButton.type = 'button';
            lightControlsButton.className = 'xeokit-i18n xeokit-light-controls xeokit-btn fa fa-lightbulb';
            lightControlsButton.setAttribute('data-tippy-content', 'Contr√¥les de lumi√®re');
            lightControlsButton.addEventListener('click', toggleLightControls);

            // Bouton des modes de vue
            const viewModesButton = document.createElement('button');
            viewModesButton.type = 'button';
            viewModesButton.className = 'xeokit-i18n xeokit-view-modes xeokit-btn fa fa-palette';
            viewModesButton.setAttribute('data-tippy-content', 'Modes de vue');
            viewModesButton.addEventListener('click', toggleViewModes);

            // Bouton pour nettoyer et afficher le mod√®le
            const cleanShowButton = document.createElement('button');
            cleanShowButton.type = 'button';
            cleanShowButton.className = 'xeokit-i18n xeokit-clean-show xeokit-btn fa fa-magic';
            cleanShowButton.setAttribute('data-tippy-content', 'Nettoyer et Afficher le Mod√®le');
            cleanShowButton.addEventListener('click', cleanAndShowModel);

            // Bouton pour nettoyer l'interface
            const cleanButton = document.createElement('button');
            cleanButton.type = 'button';
            cleanButton.className = 'xeokit-i18n xeokit-clean xeokit-btn fa fa-broom';
            cleanButton.setAttribute('data-tippy-content', 'Nettoyer l\'Interface');
            cleanButton.addEventListener('click', cleanInterface);

            // Bouton pour centrer tous les mod√®les
            const centerAllButton = document.createElement('button');
            centerAllButton.type = 'button';
            centerAllButton.className = 'xeokit-i18n xeokit-center-all xeokit-btn fa fa-bullseye';
            centerAllButton.setAttribute('data-tippy-content', 'Centrer TOUS les Mod√®les');
            centerAllButton.addEventListener('click', centerAllModels);

            // Bouton pour centrer sur le mod√®le
            const centerButton = document.createElement('button');
            centerButton.type = 'button';
            centerButton.className = 'xeokit-i18n xeokit-center xeokit-btn fa fa-search';
            centerButton.setAttribute('data-tippy-content', 'Centrer sur le Mod√®le');
            centerButton.addEventListener('click', resetCameraToModel);





            // Ajouter les boutons toujours visibles
            alwaysVisibleContainer.appendChild(themeButton);
            alwaysVisibleContainer.appendChild(screenshotButton);
            alwaysVisibleContainer.appendChild(explodeButton);
            alwaysVisibleContainer.appendChild(toggleSlideButton);

            // Ajouter les boutons coulissants
            slidingContainer.appendChild(infoButton);
            slidingContainer.appendChild(exportButton);
            slidingContainer.appendChild(annotationButton);
            slidingContainer.appendChild(lightControlsButton);
            slidingContainer.appendChild(viewModesButton);
            slidingContainer.appendChild(cleanShowButton);
            slidingContainer.appendChild(cleanButton);
            slidingContainer.appendChild(centerAllButton);
            slidingContainer.appendChild(centerButton);

            // Masquer les boutons coulissants par d√©faut
            slidingContainer.classList.add('hidden');

            // Assembler le groupe principal
            customButtonGroup.appendChild(alwaysVisibleContainer);
            customButtonGroup.appendChild(slidingContainer);

            // Ajouter le groupe √† la barre d'outils (√† la fin)
            toolbar.appendChild(customButtonGroup);

            // Initialiser les tooltips pour tous les boutons
            if (window.tippy) {
                tippy(themeButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(screenshotButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(toggleSlideButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(exportButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(infoButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(annotationButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(lightControlsButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(viewModesButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(cleanShowButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(cleanButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(centerAllButton, { appendTo: "parent", zIndex: 1000000 });
                tippy(centerButton, { appendTo: "parent", zIndex: 1000000 });
            }

            // Activer les boutons une fois le mod√®le charg√©
            bimViewer.on("modelLoaded", () => {
                themeButton.classList.remove('disabled');
                screenshotButton.classList.remove('disabled');
                toggleSlideButton.classList.remove('disabled');
                exportButton.classList.remove('disabled');
                infoButton.classList.remove('disabled');
                annotationButton.classList.remove('disabled');
                lightControlsButton.classList.remove('disabled');
                viewModesButton.classList.remove('disabled');
                cleanShowButton.classList.remove('disabled');
                cleanButton.classList.remove('disabled');
                centerAllButton.classList.remove('disabled');
                centerButton.classList.remove('disabled');

                console.log('‚úÖ All custom buttons enabled after model load');

                // Initialiser l'√©tat du bouton de th√®me
                const currentTheme = localStorage.getItem('theme') || 'light';
                updateToolbarThemeButton(currentTheme);
                updateToggleButtonsTheme(currentTheme);

                // Initialiser le mode First Person am√©lior√©
                setTimeout(() => {
                    setupFirstPersonMode();
                }, 1500);

                // Initialiser les contr√¥les de lumi√®re
                initializeLightControls();

                // Initialiser les raccourcis clavier
                initializeKeyboardShortcuts();

                // Mettre √† jour le statut de chargement
                updateLoadingStatus('Mod√®le charg√© avec succ√®s !');
                setTimeout(() => {
                    document.getElementById('loadingOverlay').style.display = 'none';

                    // Diagnostic initial
                    console.log('=== INITIAL MODEL STATE ===');
                    const diagnosis = diagnoseModelVisibility();

                    if (diagnosis && diagnosis.error) {
                        console.error('üö® PROBLEM DETECTED:', diagnosis.error);
                        console.log('üí° Try running: emergencyModelRestore()');
                    } else if (diagnosis && diagnosis.visibleObjects === 0) {
                        console.error('üö® NO VISIBLE OBJECTS! Running emergency restore...');
                        emergencyModelRestore();
                    } else if (diagnosis && diagnosis.visibleObjects > 0) {
                        console.log('‚úÖ Model loaded successfully!');
                        console.log('üîç Checking camera position...');

                        // V√©rifier la position de la cam√©ra
                        setTimeout(() => {
                            diagnoseCameraPosition();
                            console.log('üí° If you don\'t see the model, try: resetCameraToModel()');
                        }, 500);
                    }

                    console.log('üìã Available commands:');
                    console.log('  - cleanAndShowModel() : CLEAN INTERFACE + SHOW MODEL (RECOMMENDED)');
                    console.log('  - cleanInterface() : Remove all parasitic elements');
                    console.log('  - centerAllModels() : CENTER ALL MODELS');
                    console.log('  - diagnoseModelVisibility() : Check model state');
                    console.log('  - diagnoseCameraPosition() : Check camera position');
                    console.log('  - diagnoseWebGL() : Check WebGL context');
                    console.log('  - resetCameraToModel() : Reset camera to model');
                    console.log('  - forceRender() : Force scene rendering');
                    console.log('  - ensureModelVisibility() : Restore hidden objects');
                    console.log('  - emergencyModelRestore() : Full model restore');
                }, 1000);
            });
        }

        // Fonction de basculement de th√®me pour le bouton de la barre d'outils
        function toggleTheme() {
            const newTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateToolbarThemeButton(newTheme);
            updateToggleButtonsTheme(newTheme);
        }

        function updateToggleButtonsTheme(theme) {
            const explorerToggle = document.querySelector('.explorer_toggle_label');
            const inspectorToggle = document.querySelector('.inspector_toggle_label');
            const allButtons = document.querySelectorAll('.xeokit-btn');
            const tabs = document.querySelectorAll('.xeokit-tabs');
            const tabContents = document.querySelectorAll('.xeokit-tab-content');
            const explorer = document.getElementById('myExplorer');

            // Mettre √† jour tous les boutons avec les nouvelles couleurs
            if (theme === 'dark') {
                // Th√®me sombre : tous les boutons en noir
                allButtons.forEach(button => {
                    button.style.backgroundColor = '#000000';
                    button.style.color = 'white';
                    button.style.border = 'none';
                });

                if (explorerToggle) {
                    explorerToggle.style.backgroundColor = '#000000';
                    explorerToggle.style.color = 'white';
                    explorerToggle.style.border = 'none';
                }

                if (inspectorToggle) {
                    inspectorToggle.style.backgroundColor = '#000000';
                    inspectorToggle.style.color = 'white';
                    inspectorToggle.style.border = 'none';
                }
            } else {
                // Th√®me clair : tous les boutons en #03103F
                allButtons.forEach(button => {
                    button.style.backgroundColor = '#03103F';
                    button.style.color = 'white';
                    button.style.border = 'none';
                });

                if (explorerToggle) {
                    explorerToggle.style.backgroundColor = '#03103F';
                    explorerToggle.style.color = 'white';
                    explorerToggle.style.border = 'none';
                }

                if (inspectorToggle) {
                    inspectorToggle.style.backgroundColor = '#03103F';
                    inspectorToggle.style.color = 'white';
                    inspectorToggle.style.border = 'none';
                }
            }

            // Appliquer le th√®me aux onglets
            tabs.forEach(tab => {
                if (theme === 'dark') {
                    tab.style.backgroundColor = '#000000';
                    tab.style.color = 'white';
                    tab.style.border = 'none';
                } else {
                    tab.style.backgroundColor = '#03103F';
                    tab.style.color = 'white';
                    tab.style.border = 'none';
                }
            });

            // Appliquer le th√®me aux contenus d'onglets
            tabContents.forEach(content => {
                if (theme === 'dark') {
                    content.style.backgroundColor = '#000000';
                    content.style.color = 'white';
                } else {
                    content.style.backgroundColor = '#03103F';
                    content.style.color = 'white';
                }
            });

            // Appliquer le th√®me √† l'explorateur
            if (explorer) {
                if (theme === 'dark') {
                    explorer.style.backgroundColor = '#1a1a1a';
                    explorer.style.color = '#ffffff';
                    explorer.style.border = '1px solid #404040';
                } else {
                    explorer.style.backgroundColor = '#ffffff';
                    explorer.style.color = '#333333';
                    explorer.style.border = 'none';
                }
            }
        }

        function updateToolbarThemeButton(theme) {
            const themeButton = document.getElementById('toolbarThemeToggle');
            if (themeButton) {
                if (theme === 'dark') {
                    themeButton.className = themeButton.className.replace('fa-moon', 'fa-sun');
                    themeButton.classList.add('active');
                } else {
                    themeButton.className = themeButton.className.replace('fa-sun', 'fa-moon');
                    themeButton.classList.remove('active');
                }
            }
        }

        // 10. Contr√¥les de lumi√®re
        let lightSettings = {
            intensity: 1.0,
            elevation: 45,
            azimuth: 315,
            indirect: 0.4,
            sunShadows: false
        };

        function initializeLightControls() {
            const scene = bimViewer.viewer.scene;

            // Initialiser les valeurs d'affichage
            updateLightDisplayValues();

            // Configurer le bouton des ombres du soleil
            const sunShadowsToggle = document.getElementById('sunShadowsToggle');
            sunShadowsToggle.addEventListener('click', () => {
                lightSettings.sunShadows = !lightSettings.sunShadows;
                sunShadowsToggle.textContent = lightSettings.sunShadows ? 'Enabled' : 'Disabled';
                sunShadowsToggle.classList.toggle('active', lightSettings.sunShadows);

                // Appliquer les ombres (si support√© par xeokit)
                if (scene.lights && scene.lights.lights) {
                    scene.lights.lights.forEach(light => {
                        if (light.type === 'dir') {
                            light.castsShadow = lightSettings.sunShadows;
                        }
                    });
                }
            });
        }

        window.adjustLightProperty = function(property, delta) {
            const scene = bimViewer.viewer.scene;

            switch(property) {
                case 'intensity':
                    lightSettings.intensity = Math.max(0, Math.min(3, lightSettings.intensity + delta));
                    // Appliquer l'intensit√© aux lumi√®res
                    if (scene.lights && scene.lights.lights) {
                        scene.lights.lights.forEach(light => {
                            if (light.type === 'dir') {
                                light.intensity = lightSettings.intensity;
                            }
                        });
                    }
                    break;

                case 'elevation':
                    lightSettings.elevation = Math.max(-90, Math.min(90, lightSettings.elevation + delta));
                    updateLightDirection();
                    break;

                case 'azimuth':
                    lightSettings.azimuth = (lightSettings.azimuth + delta + 360) % 360;
                    updateLightDirection();
                    break;

                case 'indirect':
                    lightSettings.indirect = Math.max(0, Math.min(1, lightSettings.indirect + delta));
                    // Appliquer l'√©clairage indirect (ambient light)
                    if (scene.lights && scene.lights.lights) {
                        scene.lights.lights.forEach(light => {
                            if (light.type === 'ambient') {
                                light.intensity = lightSettings.indirect;
                            }
                        });
                    }
                    break;
            }

            updateLightDisplayValues();
        };

        function updateLightDirection() {
            const scene = bimViewer.viewer.scene;
            const elevRad = lightSettings.elevation * Math.PI / 180;
            const azimRad = lightSettings.azimuth * Math.PI / 180;

            const x = Math.cos(elevRad) * Math.sin(azimRad);
            const y = Math.sin(elevRad);
            const z = Math.cos(elevRad) * Math.cos(azimRad);

            // Appliquer la direction aux lumi√®res directionnelles
            if (scene.lights && scene.lights.lights) {
                scene.lights.lights.forEach(light => {
                    if (light.type === 'dir') {
                        light.dir = [-x, -y, -z];
                    }
                });
            }
        }

        function updateLightDisplayValues() {
            document.getElementById('intensityValue').textContent = lightSettings.intensity.toFixed(1);
            document.getElementById('elevationValue').textContent = lightSettings.elevation + '¬∞';
            document.getElementById('azimuthValue').textContent = lightSettings.azimuth + '¬∞';
            document.getElementById('indirectValue').textContent = lightSettings.indirect.toFixed(1);
        }

        // 11. Modes de vue
        let currentViewMode = 'rendered';
        let edgeSettings = {
            enabled: false,
            weight: 2,
            color: [0, 0, 0]
        };

        window.setViewMode = function(mode, value) {
            const scene = bimViewer.viewer.scene;
            const buttons = document.querySelectorAll('.view-mode-btn');

            // Mettre √† jour l'interface
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                    // Afficher la valeur num√©rique
                    const shortcut = btn.querySelector('.view-mode-shortcut');
                    if (value && shortcut) {
                        shortcut.textContent = value;
                    }
                }
            });

            currentViewMode = mode;

            // Appliquer le mode de vue
            console.log('Applying view mode:', mode);

            switch(mode) {
                case 'rendered':
                    // Mode rendu complet avec mat√©riaux et textures
                    scene.pbrEnabled = true;
                    scene.colorTextureEnabled = true;
                    if (scene.edgeMaterial) {
                        scene.edgeMaterial.edges = false;
                    }
                    // S'assurer que tous les objets restent visibles
                    Object.values(scene.objects).forEach(object => {
                        object.visible = true;
                        if (object.colorize !== undefined) {
                            object.colorize = null;
                        }
                        if (object.opacity !== undefined) {
                            object.opacity = 1.0;
                        }
                    });
                    break;

                case 'shaded':
                    // Mode ombr√© sans textures
                    scene.pbrEnabled = false;
                    scene.colorTextureEnabled = false;
                    if (scene.edgeMaterial) {
                        scene.edgeMaterial.edges = false;
                    }
                    // S'assurer que tous les objets restent visibles
                    Object.values(scene.objects).forEach(object => {
                        object.visible = true;
                        if (object.colorize !== undefined) {
                            object.colorize = null;
                        }
                        if (object.opacity !== undefined) {
                            object.opacity = 1.0;
                        }
                    });
                    break;

                case 'arctic':
                    // Mode blanc/arctique
                    scene.pbrEnabled = false;
                    scene.colorTextureEnabled = false;
                    if (scene.edgeMaterial) {
                        scene.edgeMaterial.edges = true;
                    }
                    // Appliquer une couleur blanche √† tous les objets
                    Object.values(scene.objects).forEach(object => {
                        object.visible = true;
                        if (object.colorize !== undefined) {
                            object.colorize = [1, 1, 1];
                        }
                        if (object.opacity !== undefined) {
                            object.opacity = 1.0;
                        }
                    });
                    break;

                case 'solid':
                    // Mode couleurs solides
                    scene.pbrEnabled = false;
                    scene.colorTextureEnabled = false;
                    if (scene.edgeMaterial) {
                        scene.edgeMaterial.edges = false;
                    }
                    // Restaurer les couleurs originales et s'assurer de la visibilit√©
                    Object.values(scene.objects).forEach(object => {
                        object.visible = true;
                        if (object.colorize !== undefined) {
                            object.colorize = null;
                        }
                        if (object.opacity !== undefined) {
                            object.opacity = 1.0;
                        }
                    });
                    break;

                case 'pen':
                    // Mode trait/contour
                    scene.pbrEnabled = false;
                    scene.colorTextureEnabled = false;
                    if (scene.edgeMaterial) {
                        scene.edgeMaterial.edges = true;
                        scene.edgeMaterial.edgeWidth = 3;
                    }
                    // Rendre les faces transparentes mais garder les objets visibles
                    Object.values(scene.objects).forEach(object => {
                        object.visible = true;
                        if (object.opacity !== undefined) {
                            object.opacity = 0.3; // Plus visible que 0.1
                        }
                    });
                    break;
            }

            // S'assurer que le mod√®le reste visible apr√®s le changement de mode
            ensureModelVisibility();
            console.log('View mode applied:', mode);
        };

        window.toggleEdges = function() {
            const scene = bimViewer.viewer.scene;
            const button = document.querySelector('[data-mode="edges"]');

            edgeSettings.enabled = !edgeSettings.enabled;
            scene.edgeMaterial.edges = edgeSettings.enabled;

            button.classList.toggle('active', edgeSettings.enabled);
        };

        window.adjustEdgeWeight = function(delta) {
            const scene = bimViewer.viewer.scene;
            edgeSettings.weight = Math.max(0.5, Math.min(10, edgeSettings.weight + delta));
            scene.edgeMaterial.edgeWidth = edgeSettings.weight;
            document.getElementById('edgeWeightValue').textContent = edgeSettings.weight.toFixed(1);
        };

        window.changeEdgeColor = function(hexColor) {
            const scene = bimViewer.viewer.scene;
            // Convertir hex en RGB
            const r = parseInt(hexColor.substr(1, 2), 16) / 255;
            const g = parseInt(hexColor.substr(3, 2), 16) / 255;
            const b = parseInt(hexColor.substr(5, 2), 16) / 255;

            edgeSettings.color = [r, g, b];
            scene.edgeMaterial.edgeColor = edgeSettings.color;
        };

        // 12. Raccourcis clavier
        function initializeKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.shiftKey) {
                    switch(e.key) {
                        case '!': // Shift+1
                            setViewMode('rendered', 1);
                            e.preventDefault();
                            break;
                        case '@': // Shift+2
                            setViewMode('shaded', 2);
                            e.preventDefault();
                            break;
                        case '#': // Shift+3
                            setViewMode('arctic', 3);
                            e.preventDefault();
                            break;
                        case '$': // Shift+4
                            setViewMode('solid', 4);
                            e.preventDefault();
                            break;
                        case '%': // Shift+5
                            setViewMode('pen', 5);
                            e.preventDefault();
                            break;
                    }
                }
            });
        }

        // 13. Fonction de diagnostic de la cam√©ra
        window.diagnoseCameraPosition = function() {
            console.log('=== CAMERA DIAGNOSIS ===');

            if (!bimViewer || !bimViewer.viewer) {
                console.error('BIM Viewer not available');
                return null;
            }

            const camera = bimViewer.viewer.camera;
            const scene = bimViewer.viewer.scene;

            console.log('Camera position (eye):', camera.eye);
            console.log('Camera target (look):', camera.look);
            console.log('Camera up vector:', camera.up);
            console.log('Camera projection:', camera.projection);

            // V√©rifier la bo√Æte englobante du mod√®le
            try {
                const aabb = scene.getAABB();
                if (aabb) {
                    console.log('Model bounds (AABB):', aabb);

                    const center = [
                        (aabb[0] + aabb[3]) / 2,
                        (aabb[1] + aabb[4]) / 2,
                        (aabb[2] + aabb[5]) / 2
                    ];
                    console.log('Model center:', center);

                    const size = [
                        aabb[3] - aabb[0],
                        aabb[4] - aabb[1],
                        aabb[5] - aabb[2]
                    ];
                    console.log('Model size:', size);

                    // Calculer la distance de la cam√©ra au centre du mod√®le
                    const distance = Math.sqrt(
                        Math.pow(camera.eye[0] - center[0], 2) +
                        Math.pow(camera.eye[1] - center[1], 2) +
                        Math.pow(camera.eye[2] - center[2], 2)
                    );
                    console.log('Distance camera to model:', distance);

                    if (distance > Math.max(...size) * 10) {
                        console.warn('‚ö†Ô∏è Camera is very far from model!');
                        console.log('üí° Try: resetCameraToModel()');
                    }
                } else {
                    console.warn('‚ö†Ô∏è No model bounds available');
                }
            } catch (e) {
                console.error('Error getting model bounds:', e);
            }

            console.log('=== END CAMERA DIAGNOSIS ===');

            return {
                eye: camera.eye,
                look: camera.look,
                up: camera.up,
                projection: camera.projection
            };
        };

        // 14. Fonction de r√©cup√©ration d'urgence
        window.emergencyModelRestore = function() {
            console.log('üö® EMERGENCY MODEL RESTORE üö®');

            if (!bimViewer || !bimViewer.viewer || !bimViewer.viewer.scene) {
                console.error('BIM Viewer not available');
                return false;
            }

            const scene = bimViewer.viewer.scene;
            let restored = 0;

            console.log('üìä Before restore:');
            console.log('  - Models:', Object.keys(scene.models).length);
            console.log('  - Objects:', Object.keys(scene.objects).length);

            // Restaurer tous les mod√®les
            Object.values(scene.models).forEach(model => {
                console.log(`üîß Restoring model ${model.id}:`, {
                    visible: model.visible,
                    opacity: model.opacity,
                    colorize: model.colorize
                });

                model.visible = true;
                model.opacity = 1.0;
                model.colorize = null;

                // Forcer le rendu du mod√®le
                if (model.meshes) {
                    Object.values(model.meshes).forEach(mesh => {
                        mesh.visible = true;
                        mesh.opacity = 1.0;
                    });
                }

                restored++;
                console.log('‚úÖ Restored model:', model.id);
            });

            // Restaurer tous les objets avec diagnostic d√©taill√©
            let visibleCount = 0;
            let hiddenCount = 0;

            Object.values(scene.objects).forEach(object => {
                const wasVisible = object.visible;

                object.visible = true;
                object.opacity = 1.0;
                object.colorize = null;

                // R√©initialiser les propri√©t√©s de rendu
                if (object.highlighted !== undefined) object.highlighted = false;
                if (object.selected !== undefined) object.selected = false;
                if (object.xrayed !== undefined) object.xrayed = false;

                if (wasVisible) {
                    visibleCount++;
                } else {
                    hiddenCount++;
                }

                restored++;
            });

            console.log(`üìä Objects restored: ${visibleCount} were visible, ${hiddenCount} were hidden`);

            // Forcer le rendu de la sc√®ne
            try {
                // Essayer diff√©rentes m√©thodes de rendu
                if (scene.canvas && scene.canvas.redraw) {
                    scene.canvas.redraw();
                    console.log('‚úÖ Canvas redraw called');
                }

                if (scene.redraw) {
                    scene.redraw();
                    console.log('‚úÖ Scene redraw called');
                }

                // Forcer la mise √† jour des mat√©riaux
                if (scene.pbrEnabled !== undefined) {
                    const currentPbr = scene.pbrEnabled;
                    scene.pbrEnabled = !currentPbr;
                    scene.pbrEnabled = currentPbr;
                    console.log('‚úÖ PBR toggled to force update');
                }

            } catch (e) {
                console.log('‚ö†Ô∏è Redraw methods not available:', e.message);
            }

            // Diagnostic de la cam√©ra
            console.log('üìπ Camera diagnosis:');
            diagnoseCameraPosition();

            // R√©initialiser la cam√©ra pour voir le mod√®le
            console.log('üìπ Resetting camera...');
            resetCameraToModel();

            // Diagnostic final
            setTimeout(() => {
                console.log('üìä Final state check:');
                const finalVisible = Object.values(scene.objects).filter(obj => obj.visible).length;
                console.log(`  - Visible objects: ${finalVisible}/${Object.keys(scene.objects).length}`);
                console.log(`  - Camera eye: [${scene.camera.eye.map(v => v.toFixed(2)).join(', ')}]`);
                console.log(`  - Camera look: [${scene.camera.look.map(v => v.toFixed(2)).join(', ')}]`);
            }, 1000);

            console.log(`‚úÖ Restored ${restored} elements`);
            console.log('üéâ Emergency restore complete!');
            console.log('üí° If model still not visible, check WebGL context or try refreshing page');

            return true;
        };

        // 15. Fonction de diagnostic WebGL
        window.diagnoseWebGL = function() {
            console.log('=== WEBGL DIAGNOSIS ===');

            if (!bimViewer || !bimViewer.viewer || !bimViewer.viewer.scene) {
                console.error('BIM Viewer not available');
                return null;
            }

            const canvas = bimViewer.viewer.scene.canvas.canvas;
            console.log('Canvas element:', canvas);
            console.log('Canvas size:', canvas.width, 'x', canvas.height);
            console.log('Canvas style:', canvas.style.width, 'x', canvas.style.height);

            // V√©rifier le contexte WebGL
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            console.log('WebGL context:', gl);

            if (gl) {
                console.log('WebGL version:', gl.getParameter(gl.VERSION));
                console.log('WebGL vendor:', gl.getParameter(gl.VENDOR));
                console.log('WebGL renderer:', gl.getParameter(gl.RENDERER));
                console.log('WebGL max texture size:', gl.getParameter(gl.MAX_TEXTURE_SIZE));

                // V√©rifier les erreurs WebGL
                const error = gl.getError();
                if (error !== gl.NO_ERROR) {
                    console.error('WebGL error:', error);
                } else {
                    console.log('‚úÖ No WebGL errors');
                }

                // V√©rifier le viewport
                const viewport = gl.getParameter(gl.VIEWPORT);
                console.log('WebGL viewport:', viewport);

            } else {
                console.error('‚ùå WebGL not available!');
            }

            // V√©rifier si le canvas est visible
            const rect = canvas.getBoundingClientRect();
            console.log('Canvas position:', rect);
            console.log('Canvas visible:', rect.width > 0 && rect.height > 0);

            console.log('=== END WEBGL DIAGNOSIS ===');

            return {
                canvas: !!canvas,
                webgl: !!gl,
                size: { width: canvas.width, height: canvas.height },
                visible: rect.width > 0 && rect.height > 0
            };
        };

        // 16. Fonction pour forcer le rendu
        window.forceRender = function() {
            console.log('üîÑ FORCING RENDER üîÑ');

            if (!bimViewer || !bimViewer.viewer || !bimViewer.viewer.scene) {
                console.error('BIM Viewer not available');
                return false;
            }

            const scene = bimViewer.viewer.scene;

            try {
                // Essayer toutes les m√©thodes de rendu possibles
                const methods = [
                    () => scene.canvas.redraw(),
                    () => scene.redraw(),
                    () => scene.canvas.canvas.dispatchEvent(new Event('resize')),
                    () => bimViewer.viewer.scene.canvas.redraw(),
                    () => {
                        // Forcer la mise √† jour en modifiant temporairement la cam√©ra
                        const eye = [...bimViewer.viewer.camera.eye];
                        bimViewer.viewer.camera.eye = [eye[0] + 0.001, eye[1], eye[2]];
                        setTimeout(() => {
                            bimViewer.viewer.camera.eye = eye;
                        }, 10);
                    }
                ];

                methods.forEach((method, index) => {
                    try {
                        method();
                        console.log(`‚úÖ Render method ${index + 1} executed`);
                    } catch (e) {
                        console.log(`‚ö†Ô∏è Render method ${index + 1} failed:`, e.message);
                    }
                });

                console.log('üéâ Force render complete!');
                return true;

            } catch (e) {
                console.error('‚ùå Force render failed:', e);
                return false;
            }
        };

        // 17. Fonction pour centrer et afficher TOUS les mod√®les
        window.centerAllModels = function() {
            console.log('üéØ CENTERING ALL MODELS üéØ');

            if (!bimViewer || !bimViewer.viewer || !bimViewer.viewer.scene) {
                console.error('BIM Viewer not available');
                return false;
            }

            const scene = bimViewer.viewer.scene;
            const camera = bimViewer.viewer.camera;

            // 1. S'assurer que tous les mod√®les et objets sont visibles
            console.log('üìã Step 1: Making all models visible...');
            Object.values(scene.models).forEach(model => {
                model.visible = true;
                model.opacity = 1.0;
                model.colorize = null;
                console.log(`‚úÖ Model ${model.id} set to visible`);
            });

            Object.values(scene.objects).forEach(object => {
                object.visible = true;
                object.opacity = 1.0;
                object.colorize = null;
                object.highlighted = false;
                object.selected = false;
                object.xrayed = false;
            });

            // 2. Obtenir les dimensions du mod√®le
            console.log('üìã Step 2: Getting model bounds...');
            const aabb = scene.getAABB();

            if (!aabb) {
                console.error('‚ùå No model bounds available');
                return false;
            }

            console.log('Model AABB:', aabb);

            // 3. Calculer le centre et la taille
            const center = [
                (aabb[0] + aabb[3]) / 2,
                (aabb[1] + aabb[4]) / 2,
                (aabb[2] + aabb[5]) / 2
            ];

            const size = [
                aabb[3] - aabb[0],
                aabb[4] - aabb[1],
                aabb[5] - aabb[2]
            ];

            const maxSize = Math.max(...size);

            console.log('Model center:', center);
            console.log('Model size:', size);
            console.log('Max dimension:', maxSize);

            // 4. Positionner la cam√©ra √† une distance optimale
            console.log('üìã Step 3: Positioning camera...');
            const distance = maxSize * 2; // Distance = 2x la plus grande dimension
            const angle = Math.PI / 4; // 45 degr√©s

            const cameraPosition = [
                center[0] + distance * Math.cos(angle),
                center[1] + distance * 0.5,
                center[2] + distance * Math.sin(angle)
            ];

            console.log('Camera position:', cameraPosition);
            console.log('Camera target:', center);

            // 5. Appliquer la position de cam√©ra
            camera.eye = cameraPosition;
            camera.look = center;
            camera.up = [0, 1, 0];

            // 6. Utiliser cameraFlight pour une transition fluide
            console.log('üìã Step 4: Flying to model...');
            try {
                bimViewer.viewer.cameraFlight.flyTo({
                    eye: cameraPosition,
                    look: center,
                    up: [0, 1, 0],
                    duration: 2.0
                });
                console.log('‚úÖ Camera flight initiated');
            } catch (e) {
                console.log('‚ö†Ô∏è Camera flight failed, using direct positioning');
            }

            // 7. Forcer le rendu
            console.log('üìã Step 5: Forcing render...');
            setTimeout(() => {
                forceRender();

                // 8. V√©rification finale
                setTimeout(() => {
                    console.log('üìã Step 6: Final verification...');
                    const finalCamera = bimViewer.viewer.camera;
                    console.log('Final camera eye:', finalCamera.eye);
                    console.log('Final camera look:', finalCamera.look);

                    const visibleObjects = Object.values(scene.objects).filter(obj => obj.visible).length;
                    console.log(`Final visible objects: ${visibleObjects}/${Object.keys(scene.objects).length}`);

                    if (visibleObjects > 0) {
                        console.log('üéâ ALL MODELS SHOULD NOW BE VISIBLE AND CENTERED!');
                    } else {
                        console.log('‚ùå Objects still not visible - possible rendering issue');
                    }
                }, 1000);
            }, 500);

            return true;
        };

        // 18. Fonction cleanInterface d√©j√† d√©finie plus t√¥t - Exposer globalement
        window.cleanInterface = cleanInterface;

        // 19. Fonction combin√©e : nettoyer + centrer le mod√®le
        function cleanAndShowModel() {
            console.log('üéØ CLEAN AND SHOW MODEL üéØ');

            // 1. Nettoyer l'interface
            cleanInterface();

            // 2. Attendre un peu puis centrer le mod√®le
            setTimeout(() => {
                if (typeof centerAllModels === 'function') {
                    centerAllModels();
                } else {
                    console.log('centerAllModels not yet available');
                }
            }, 500);

            return true;
        }

        // Exposer globalement
        window.cleanAndShowModel = cleanAndShowModel;

        // 23. Syst√®me First Person natif xeokit am√©lior√©
        function setupFirstPersonMode() {
            const firstPersonButton = document.querySelector('.xeokit-firstPerson');

            if (!firstPersonButton) {
                console.warn('First Person button not found');
                return;
            }

            // Observer les changements du bouton First Person natif
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const isActive = firstPersonButton.classList.contains('active');
                        handleFirstPersonModeChange(isActive);
                    }
                });
            });

            observer.observe(firstPersonButton, {
                attributes: true,
                attributeFilter: ['class']
            });

            console.log('‚úÖ First Person mode native setup complete');
        }

        function handleFirstPersonModeChange(active) {
            if (active) {
                console.log('üö∂ First Person mode activated - Setting up VERY COMFORTABLE navigation for detail viewing');

                // Activer le mode First Person
                firstPersonMode = true;

                // Positionner la cam√©ra devant le mod√®le (pas √† l'int√©rieur)
                positionCameraInFrontOfModel();

                // Utiliser une vitesse TR√àS CONFORTABLE pour First Person (tr√®s lente pour voir les d√©tails)
                adjustCameraSpeed(0.5); // D√©clenche le mode First Person avec vitesse 0.4x (tr√®s lente)

                // D√©sactiver compl√®tement les contr√¥les natifs First Person
                disableNativeFirstPersonControls();

                // Activer les contr√¥les clavier personnalis√©s
                setupFirstPersonKeyboardControls();

                // Afficher le panneau de navigation natif
                showNativeNavigationPanel();

                console.log('üö∂ First Person mode ready - VERY COMFORTABLE speed (60% slower for detail viewing)');
                console.log('üìã Custom controls: Z (avant), S (arri√®re), D (rotation droite), Q (rotation gauche)');
                console.log('üéÆ Navigation speed is much slower than normal mode for comfortable detail viewing');
                console.log('üëÅÔ∏è Perfect for examining model details and immersive exploration');
            } else {
                console.log('üö∂ First Person mode deactivated - Restoring ORIGINAL speeds');

                // D√©sactiver le mode First Person
                firstPersonMode = false;

                // D√©sactiver les contr√¥les clavier personnalis√©s
                removeFirstPersonKeyboardControls();

                // Retourner aux vitesses ORIGINALES exactes
                adjustCameraSpeed(1.0); // Restaure les vitesses originales

                console.log('‚úÖ Original navigation speeds and controls fully restored');
            }
        }

        // Fonction pour d√©sactiver compl√®tement les contr√¥les natifs First Person
        function disableNativeFirstPersonControls() {
            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    // D√©sactiver tous les contr√¥les natifs
                    cameraControl.keyboardEnabled = false;
                    cameraControl.mouseEnabled = true; // Garder la souris pour regarder autour

                    // D√©sactiver les contr√¥les First Person natifs sp√©cifiques
                    if (cameraControl.firstPersonKeyboardEnabled !== undefined) {
                        cameraControl.firstPersonKeyboardEnabled = false;
                    }
                    if (cameraControl.firstPersonMouseEnabled !== undefined) {
                        cameraControl.firstPersonMouseEnabled = true; // Garder pour regarder
                    }

                    console.log('üö´ ALL native First Person controls disabled - only custom Z/S/D/Q active');
                }
            } catch (e) {
                console.error('‚ùå Error disabling native First Person controls:', e);
            }
        }

        // Fonctions pour les contr√¥les clavier First Person personnalis√©s
        function setupFirstPersonKeyboardControls() {
            // Sauvegarder l'√©tat des contr√¥les natifs et les d√©sactiver
            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;
                    originalKeyboardEnabled = cameraControl.keyboardEnabled;
                    cameraControl.keyboardEnabled = false;
                    console.log('üö´ Native keyboard controls DISABLED for First Person mode');
                }
            } catch (e) {
                console.error('‚ùå Error disabling native controls:', e);
            }

            // Activer nos contr√¥les personnalis√©s
            document.addEventListener('keydown', onFirstPersonKeyDown);
            document.addEventListener('keyup', onFirstPersonKeyUp);
            console.log('‚å®Ô∏è Custom First Person keyboard controls activated: Z/S/D/Q');
        }

        function removeFirstPersonKeyboardControls() {
            // D√©sactiver nos contr√¥les personnalis√©s
            document.removeEventListener('keydown', onFirstPersonKeyDown);
            document.removeEventListener('keyup', onFirstPersonKeyUp);
            firstPersonKeyStates = {};
            if (firstPersonAnimationFrame) {
                cancelAnimationFrame(firstPersonAnimationFrame);
                firstPersonAnimationFrame = null;
            }

            // R√©activer les contr√¥les natifs
            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;
                    cameraControl.keyboardEnabled = originalKeyboardEnabled;
                    console.log('‚úÖ Native keyboard controls RESTORED');
                }
            } catch (e) {
                console.error('‚ùå Error restoring native controls:', e);
            }

            console.log('‚å®Ô∏è Custom First Person keyboard controls deactivated');
        }

        function onFirstPersonKeyDown(event) {
            if (!firstPersonMode) return;

            const key = event.key.toLowerCase();

            // Contr√¥les First Person sp√©ciaux
            if (['z', 's', 'd', 'q'].includes(key)) {
                event.preventDefault(); // Emp√™cher les contr√¥les par d√©faut
                event.stopPropagation(); // Emp√™cher la propagation vers d'autres handlers
                event.stopImmediatePropagation(); // Emp√™cher tous les autres handlers

                firstPersonKeyStates[key] = true;

                if (!firstPersonAnimationFrame) {
                    firstPersonMovementLoop();
                }

                console.log('üéÆ First Person key pressed:', key.toUpperCase(), '- Native controls blocked');
                return false; // Emp√™cher compl√®tement le comportement par d√©faut
            }
        }

        function onFirstPersonKeyUp(event) {
            if (!firstPersonMode) return;

            const key = event.key.toLowerCase();

            if (['z', 's', 'd', 'q'].includes(key)) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();

                firstPersonKeyStates[key] = false;
                console.log('üéÆ First Person key released:', key.toUpperCase());
                return false;
            }
        }

        function firstPersonMovementLoop() {
            if (!firstPersonMode) {
                firstPersonAnimationFrame = null;
                return;
            }

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.scene) {
                    const camera = bimViewer.viewer.scene.camera;
                    const moveSpeed = 0.3; // Vitesse de mouvement tr√®s lente
                    const rotateSpeed = 0.8; // Vitesse de rotation lente

                    let moved = false;

                    // Z - Avancer
                    if (firstPersonKeyStates['z']) {
                        const forward = [
                            camera.look[0] - camera.eye[0],
                            0, // Pas de mouvement vertical
                            camera.look[2] - camera.eye[2]
                        ];
                        const length = Math.sqrt(forward[0] * forward[0] + forward[2] * forward[2]);
                        if (length > 0) {
                            forward[0] = (forward[0] / length) * moveSpeed;
                            forward[2] = (forward[2] / length) * moveSpeed;

                            camera.eye = [camera.eye[0] + forward[0], camera.eye[1], camera.eye[2] + forward[2]];
                            camera.look = [camera.look[0] + forward[0], camera.look[1], camera.look[2] + forward[2]];
                            moved = true;
                        }
                    }

                    // S - Reculer
                    if (firstPersonKeyStates['s']) {
                        const backward = [
                            camera.eye[0] - camera.look[0],
                            0,
                            camera.eye[2] - camera.look[2]
                        ];
                        const length = Math.sqrt(backward[0] * backward[0] + backward[2] * backward[2]);
                        if (length > 0) {
                            backward[0] = (backward[0] / length) * moveSpeed;
                            backward[2] = (backward[2] / length) * moveSpeed;

                            camera.eye = [camera.eye[0] + backward[0], camera.eye[1], camera.eye[2] + backward[2]];
                            camera.look = [camera.look[0] + backward[0], camera.look[1], camera.look[2] + backward[2]];
                            moved = true;
                        }
                    }

                    // D - Rotation droite
                    if (firstPersonKeyStates['d']) {
                        const dx = camera.look[0] - camera.eye[0];
                        const dz = camera.look[2] - camera.eye[2];
                        const angle = Math.atan2(dz, dx) - rotateSpeed * 0.02;
                        const distance = Math.sqrt(dx * dx + dz * dz);

                        camera.look = [
                            camera.eye[0] + Math.cos(angle) * distance,
                            camera.look[1],
                            camera.eye[2] + Math.sin(angle) * distance
                        ];
                        moved = true;
                    }

                    // Q - Rotation gauche
                    if (firstPersonKeyStates['q']) {
                        const dx = camera.look[0] - camera.eye[0];
                        const dz = camera.look[2] - camera.eye[2];
                        const angle = Math.atan2(dz, dx) + rotateSpeed * 0.02;
                        const distance = Math.sqrt(dx * dx + dz * dz);

                        camera.look = [
                            camera.eye[0] + Math.cos(angle) * distance,
                            camera.look[1],
                            camera.eye[2] + Math.sin(angle) * distance
                        ];
                        moved = true;
                    }
                }
            } catch (e) {
                console.error('‚ùå Error in First Person movement:', e);
            }

            // Continuer la boucle si des touches sont press√©es
            const anyKeyPressed = Object.values(firstPersonKeyStates).some(pressed => pressed);
            if (anyKeyPressed) {
                firstPersonAnimationFrame = requestAnimationFrame(firstPersonMovementLoop);
            } else {
                firstPersonAnimationFrame = null;
            }
        }

        function positionCameraInFrontOfModel() {
            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.scene) {
                    const scene = bimViewer.viewer.scene;
                    const camera = scene.camera;

                    // Obtenir les limites du mod√®le
                    const aabb = scene.getAABB(scene.visibleObjectIds);
                    if (aabb) {
                        // Calculer le centre et les dimensions du mod√®le
                        const centerX = (aabb[0] + aabb[3]) / 2;
                        const centerY = (aabb[1] + aabb[4]) / 2;
                        const centerZ = (aabb[2] + aabb[5]) / 2;

                        const sizeX = aabb[3] - aabb[0];
                        const sizeY = aabb[4] - aabb[1];
                        const sizeZ = aabb[5] - aabb[2];
                        const maxSize = Math.max(sizeX, sizeY, sizeZ);

                        // Positionner la cam√©ra devant le mod√®le √† hauteur humaine
                        const eyeY = aabb[1] + 1.7; // Sol + hauteur humaine (1.7m)
                        const distance = maxSize * 0.8; // Distance confortable devant le mod√®le

                        camera.eye = [centerX, eyeY, centerZ + distance];
                        camera.look = [centerX, eyeY, centerZ];
                        camera.up = [0, 1, 0];

                        console.log('üìç Camera positioned in front of model at human height:', camera.eye);
                    }
                }
            } catch (e) {
                console.error('‚ùå Error positioning camera in front of model:', e);
            }
        }

        // Variables pour sauvegarder les vitesses originales
        let originalCameraSpeeds = null;

        // Variables pour les contr√¥les First Person personnalis√©s
        let firstPersonMode = false;
        let firstPersonKeyStates = {};
        let firstPersonAnimationFrame = null;
        let originalKeyboardEnabled = true;

        function adjustCameraSpeed(speedFactor) {
            console.log('üîß adjustCameraSpeed called with speedFactor:', speedFactor);
            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;
                    console.log('‚úÖ Camera control found:', !!cameraControl);

                    // Sauvegarder les vitesses originales la premi√®re fois
                    if (!originalCameraSpeeds) {
                        originalCameraSpeeds = {
                            panRate: cameraControl.panRate || 5.0,
                            keyboardPanRate: cameraControl.keyboardPanRate || 1.0,
                            mouseWheelDollyRate: cameraControl.mouseWheelDollyRate || 10.0,
                            dollyRate: cameraControl.dollyRate || 2.0,
                            keyboardDollyRate: cameraControl.keyboardDollyRate || 1.0,
                            mouseSensitivity: cameraControl.mouseSensitivity || 1.0,
                            firstPersonKeyboardDollyRate: cameraControl.firstPersonKeyboardDollyRate || 1.0,
                            firstPersonKeyboardPanRate: cameraControl.firstPersonKeyboardPanRate || 1.0
                        };
                        console.log('üíæ Original camera speeds saved:', originalCameraSpeeds);
                    }

                    // Afficher les vitesses actuelles AVANT modification
                    console.log('üìä Current speeds BEFORE modification:');
                    console.log('  - panRate:', cameraControl.panRate);
                    console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                    console.log('  - dollyRate:', cameraControl.dollyRate);
                    console.log('  - keyboardDollyRate:', cameraControl.keyboardDollyRate);

                    if (speedFactor < 1.0) {
                        // Mode First Person - Vitesse confortable pour voir les d√©tails
                        console.log('üö∂ Setting up First Person mode with VERY COMFORTABLE speed (0.4x = 60% slower)');

                        // Multiplicateur tr√®s r√©duit pour navigation tr√®s confortable (60% plus lent que normal)
                        const firstPersonMultiplier = 0.4;
                        console.log('üîß Using multiplier:', firstPersonMultiplier);
                        console.log('üîß Original speeds to modify:', originalCameraSpeeds);

                        // FORCER les nouvelles vitesses
                        const newPanRate = originalCameraSpeeds.panRate * firstPersonMultiplier;
                        const newKeyboardPanRate = originalCameraSpeeds.keyboardPanRate * firstPersonMultiplier;
                        const newDollyRate = originalCameraSpeeds.dollyRate * firstPersonMultiplier;
                        const newKeyboardDollyRate = originalCameraSpeeds.keyboardDollyRate * firstPersonMultiplier;
                        const newMouseWheelDollyRate = originalCameraSpeeds.mouseWheelDollyRate * firstPersonMultiplier;

                        console.log('üîß Calculated new speeds:');
                        console.log('  - newPanRate:', newPanRate);
                        console.log('  - newKeyboardPanRate:', newKeyboardPanRate);
                        console.log('  - newDollyRate:', newDollyRate);

                        cameraControl.panRate = newPanRate;
                        cameraControl.keyboardPanRate = newKeyboardPanRate;
                        cameraControl.mouseWheelDollyRate = newMouseWheelDollyRate;
                        cameraControl.dollyRate = newDollyRate;
                        cameraControl.keyboardDollyRate = newKeyboardDollyRate;

                        // Param√®tres sp√©cifiques au mode First Person (vitesse tr√®s augment√©e)
                        if (cameraControl.firstPersonKeyboardDollyRate !== undefined) {
                            cameraControl.firstPersonKeyboardDollyRate = originalCameraSpeeds.firstPersonKeyboardDollyRate * firstPersonMultiplier;
                        }
                        if (cameraControl.firstPersonKeyboardPanRate !== undefined) {
                            cameraControl.firstPersonKeyboardPanRate = originalCameraSpeeds.firstPersonKeyboardPanRate * firstPersonMultiplier;
                        }

                        // Sensibilit√© de la souris tr√®s augment√©e
                        if (cameraControl.mouseSensitivity !== undefined) {
                            cameraControl.mouseSensitivity = originalCameraSpeeds.mouseSensitivity * firstPersonMultiplier;
                        }

                        // Activer les contr√¥les clavier
                        cameraControl.keyboardEnabled = true;

                        // V√©rifier que les changements ont √©t√© appliqu√©s
                        console.log('üìä Speeds AFTER First Person modification:');
                        console.log('  - panRate:', cameraControl.panRate);
                        console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                        console.log('  - dollyRate:', cameraControl.dollyRate);
                        console.log('  - keyboardDollyRate:', cameraControl.keyboardDollyRate);
                        console.log('  - mouseSensitivity:', cameraControl.mouseSensitivity);

                        console.log('üö∂ First Person VERY COMFORTABLE speed configured (0.4x = 60% slower for detail viewing):');
                        console.log('  - Expected Pan rate:', originalCameraSpeeds.panRate * firstPersonMultiplier);
                        console.log('  - Actual Pan rate:', cameraControl.panRate);
                        console.log('  - Expected Keyboard rate:', originalCameraSpeeds.keyboardPanRate * firstPersonMultiplier);
                        console.log('  - Actual Keyboard rate:', cameraControl.keyboardPanRate);

                    } else {
                        // Mode normal - Restaurer les vitesses ORIGINALES exactes
                        console.log('üéÆ Restoring ORIGINAL navigation speeds');

                        cameraControl.panRate = originalCameraSpeeds.panRate;
                        cameraControl.keyboardPanRate = originalCameraSpeeds.keyboardPanRate;
                        cameraControl.mouseWheelDollyRate = originalCameraSpeeds.mouseWheelDollyRate;
                        cameraControl.dollyRate = originalCameraSpeeds.dollyRate;
                        cameraControl.keyboardDollyRate = originalCameraSpeeds.keyboardDollyRate;

                        if (cameraControl.firstPersonKeyboardDollyRate !== undefined) {
                            cameraControl.firstPersonKeyboardDollyRate = originalCameraSpeeds.firstPersonKeyboardDollyRate;
                        }
                        if (cameraControl.firstPersonKeyboardPanRate !== undefined) {
                            cameraControl.firstPersonKeyboardPanRate = originalCameraSpeeds.firstPersonKeyboardPanRate;
                        }
                        if (cameraControl.mouseSensitivity !== undefined) {
                            cameraControl.mouseSensitivity = originalCameraSpeeds.mouseSensitivity;
                        }

                        cameraControl.keyboardEnabled = true;

                        // V√©rifier que les changements ont √©t√© appliqu√©s
                        console.log('üìä Speeds AFTER Normal mode restoration:');
                        console.log('  - panRate:', cameraControl.panRate);
                        console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                        console.log('  - dollyRate:', cameraControl.dollyRate);
                        console.log('  - keyboardDollyRate:', cameraControl.keyboardDollyRate);

                        console.log('üéÆ Original speeds restored:');
                        console.log('  - Expected Pan rate:', originalCameraSpeeds.panRate);
                        console.log('  - Actual Pan rate:', cameraControl.panRate);
                        console.log('  - Expected Keyboard rate:', originalCameraSpeeds.keyboardPanRate);
                        console.log('  - Actual Keyboard rate:', cameraControl.keyboardPanRate);
                    }

                    console.log('üéÆ Camera speed adjustment complete');
                }
            } catch (e) {
                console.error('‚ùå Error adjusting camera speed:', e);
            }
        }

        // Fonction pour forcer l'affichage du panneau de navigation natif
        function showNativeNavigationPanel() {
            try {
                console.log('üìã Checking for native navigation panel...');

                // V√©rifier si le BIM Viewer a des contr√¥les de navigation
                if (bimViewer && bimViewer._firstPersonMode) {
                    console.log('üéÆ First Person mode object found:', !!bimViewer._firstPersonMode);
                }

                // Chercher le panneau de navigation dans le DOM
                setTimeout(() => {
                    const navigationPanels = document.querySelectorAll('[class*="navigation"], [class*="firstPerson"], [id*="navigation"], [id*="firstPerson"]');
                    console.log('üîç Found potential navigation panels:', navigationPanels.length);

                    navigationPanels.forEach((panel, index) => {
                        console.log(`üìã Panel ${index + 1}:`, panel.className, panel.id);
                        // Forcer l'affichage si masqu√©
                        if (panel.style.display === 'none') {
                            panel.style.display = 'block';
                            console.log('üëÅÔ∏è Panel forced visible');
                        }
                    });

                    // V√©rifier les √©l√©ments avec "Param√©trage" dans le texte
                    const allElements = document.querySelectorAll('*');
                    allElements.forEach(element => {
                        if (element.textContent && element.textContent.includes('Param√©trage')) {
                            console.log('üìã Found navigation panel with "Param√©trage":', element);
                            if (element.style.display === 'none') {
                                element.style.display = 'block';
                                console.log('üëÅÔ∏è Navigation panel forced visible');
                            }
                        }
                    });
                }, 500);

            } catch (e) {
                console.error('‚ùå Error checking navigation panel:', e);
            }
        }

        // Fonction pour ajuster la vitesse de navigation en temps r√©el
        window.setNavigationSpeed = function(speed) {
            if (speed < 0.1) speed = 0.1;   // Minimum raisonnable
            if (speed > 3.0) speed = 3.0;   // Maximum raisonnable

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    // Vitesses de base normales
                    const baseSpeed = {
                        panRate: 5.0,
                        keyboardPanRate: 1.0,
                        dollyRate: 2.0,
                        keyboardDollyRate: 1.0,
                        mouseWheelDollyRate: 10.0
                    };

                    // Appliquer le multiplicateur de vitesse
                    cameraControl.panRate = baseSpeed.panRate * speed;
                    cameraControl.keyboardPanRate = baseSpeed.keyboardPanRate * speed;
                    cameraControl.dollyRate = baseSpeed.dollyRate * speed;
                    cameraControl.keyboardDollyRate = baseSpeed.keyboardDollyRate * speed;
                    cameraControl.mouseWheelDollyRate = baseSpeed.mouseWheelDollyRate * speed;

                    if (cameraControl.firstPersonKeyboardDollyRate !== undefined) {
                        cameraControl.firstPersonKeyboardDollyRate = baseSpeed.keyboardDollyRate * speed;
                    }
                    if (cameraControl.firstPersonKeyboardPanRate !== undefined) {
                        cameraControl.firstPersonKeyboardPanRate = baseSpeed.keyboardPanRate * speed;
                    }

                    console.log('üéÆ Navigation speed adjusted to:', speed + 'x');
                    console.log('  - Use setNavigationSpeed(0.5) for slower');
                    console.log('  - Use setNavigationSpeed(1.0) for normal');
                    console.log('  - Use setNavigationSpeed(1.5) for faster');
                }
            } catch (e) {
                console.error('‚ùå Error adjusting navigation speed:', e);
            }
        };

        // Alias pour compatibilit√©
        window.setWalkingSpeed = window.setNavigationSpeed;

        // Fonction pour ajuster le multiplicateur de vitesse First Person
        window.setFirstPersonSpeedMultiplier = function(multiplier) {
            if (multiplier < 0.5) multiplier = 0.5;   // Minimum 50% de la vitesse normale
            if (multiplier > 3.0) multiplier = 3.0;   // Maximum 300% de la vitesse normale

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    // Vitesses de base normales
                    const baseSpeed = {
                        panRate: 5.0,
                        keyboardPanRate: 1.0,
                        dollyRate: 2.0,
                        keyboardDollyRate: 1.0,
                        mouseWheelDollyRate: 10.0,
                        mouseSensitivity: 1.0
                    };

                    // Appliquer le multiplicateur First Person
                    cameraControl.panRate = baseSpeed.panRate * multiplier;
                    cameraControl.keyboardPanRate = baseSpeed.keyboardPanRate * multiplier;
                    cameraControl.dollyRate = baseSpeed.dollyRate * multiplier;
                    cameraControl.keyboardDollyRate = baseSpeed.keyboardDollyRate * multiplier;
                    cameraControl.mouseWheelDollyRate = baseSpeed.mouseWheelDollyRate * multiplier;

                    if (cameraControl.firstPersonKeyboardDollyRate !== undefined) {
                        cameraControl.firstPersonKeyboardDollyRate = baseSpeed.keyboardDollyRate * multiplier;
                    }
                    if (cameraControl.firstPersonKeyboardPanRate !== undefined) {
                        cameraControl.firstPersonKeyboardPanRate = baseSpeed.keyboardPanRate * multiplier;
                    }
                    if (cameraControl.mouseSensitivity !== undefined) {
                        cameraControl.mouseSensitivity = baseSpeed.mouseSensitivity * multiplier;
                    }

                    console.log('üö∂ First Person speed multiplier set to:', multiplier + 'x');
                    console.log('  - Use setFirstPersonSpeedMultiplier(1.0) for normal speed');
                    console.log('  - Use setFirstPersonSpeedMultiplier(1.3) for 30% faster (current)');
                    console.log('  - Use setFirstPersonSpeedMultiplier(1.5) for 50% faster');
                    console.log('  - Use setFirstPersonSpeedMultiplier(0.8) for 20% slower');
                }
            } catch (e) {
                console.error('‚ùå Error adjusting First Person speed multiplier:', e);
            }
        };





        // 22. Fonction pour r√©initialiser la cam√©ra (accessible globalement)
        window.resetCameraToModel = resetCameraToModel;

        // 24. Fonctions de test pour les panneaux
        window.testLightControls = function() {
            console.log('üß™ Testing Light Controls Panel');
            const panel = document.getElementById('lightControlsPanel');
            const button = document.querySelector('.xeokit-light-controls');

            console.log('Panel found:', !!panel);
            console.log('Button found:', !!button);

            if (panel) {
                console.log('Panel classes:', panel.className);
                console.log('Panel style display:', panel.style.display);
                console.log('Panel style visibility:', panel.style.visibility);
                console.log('Panel style opacity:', panel.style.opacity);
                console.log('Panel style transform:', panel.style.transform);

                // Forcer l'affichage pour test
                panel.style.display = 'block';
                panel.style.visibility = 'visible';
                panel.style.opacity = '1';
                panel.style.transform = 'translateX(0)';
                panel.style.zIndex = '1000';
                panel.classList.add('visible');

                console.log('üß™ Light controls panel forced visible');
            }
        };

        window.testViewModes = function() {
            console.log('üß™ Testing View Modes Panel');
            const panel = document.getElementById('viewModesPanel');
            const button = document.querySelector('.xeokit-view-modes');

            console.log('Panel found:', !!panel);
            console.log('Button found:', !!button);

            if (panel) {
                console.log('Panel classes:', panel.className);
                console.log('Panel style display:', panel.style.display);
                console.log('Panel style visibility:', panel.style.visibility);
                console.log('Panel style opacity:', panel.style.opacity);
                console.log('Panel style transform:', panel.style.transform);

                // Forcer l'affichage pour test
                panel.style.display = 'block';
                panel.style.visibility = 'visible';
                panel.style.opacity = '1';
                panel.style.transform = 'translateX(0)';
                panel.style.zIndex = '1000';
                panel.classList.add('visible');

                console.log('üß™ View modes panel forced visible');
            }
        };

        // Fonction de diagnostic pour les vitesses de navigation
        window.checkNavigationSpeed = function() {
            console.log('üîç Checking current navigation speeds:');

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    console.log('üìä Current camera control settings:');
                    console.log('  - panRate:', cameraControl.panRate);
                    console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                    console.log('  - dollyRate:', cameraControl.dollyRate);
                    console.log('  - keyboardDollyRate:', cameraControl.keyboardDollyRate);
                    console.log('  - mouseWheelDollyRate:', cameraControl.mouseWheelDollyRate);
                    console.log('  - keyboardEnabled:', cameraControl.keyboardEnabled);
                    console.log('  - navMode:', cameraControl.navMode);

                    if (cameraControl.firstPersonKeyboardDollyRate !== undefined) {
                        console.log('  - firstPersonKeyboardDollyRate:', cameraControl.firstPersonKeyboardDollyRate);
                    }
                    if (cameraControl.firstPersonKeyboardPanRate !== undefined) {
                        console.log('  - firstPersonKeyboardPanRate:', cameraControl.firstPersonKeyboardPanRate);
                    }
                    if (cameraControl.mouseSensitivity !== undefined) {
                        console.log('  - mouseSensitivity:', cameraControl.mouseSensitivity);
                    }

                    console.log('üí° To adjust First Person speed, use: setFirstPersonSpeedMultiplier(1.3) for 30% faster');
                    console.log('üí° Current multiplier appears to be: ~1.3x (if in First Person mode)');
                } else {
                    console.error('‚ùå Camera control not found');
                }
            } catch (e) {
                console.error('‚ùå Error checking navigation speed:', e);
            }
        };

        // Fonction pour v√©rifier la sauvegarde des vitesses originales
        window.checkOriginalSpeeds = function() {
            console.log('üîç Checking original speeds backup:');

            if (originalCameraSpeeds) {
                console.log('üíæ Original speeds saved:', originalCameraSpeeds);
            } else {
                console.log('‚ùå No original speeds saved yet');
            }

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;
                    console.log('üìä Current speeds:');
                    console.log('  - panRate:', cameraControl.panRate);
                    console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                    console.log('  - dollyRate:', cameraControl.dollyRate);
                    console.log('  - mouseSensitivity:', cameraControl.mouseSensitivity);
                }
            } catch (e) {
                console.error('‚ùå Error checking current speeds:', e);
            }
        };

        // Fonction pour forcer la restauration des vitesses originales
        window.forceRestoreOriginalSpeeds = function() {
            console.log('üîß Force restoring original speeds...');
            adjustCameraSpeed(1.0);
            console.log('‚úÖ Original speeds force restored');
        };

        // Fonction pour diagnostiquer le panneau de navigation
        window.findNavigationPanel = function() {
            console.log('üîç Searching for navigation panel...');

            // Chercher tous les √©l√©ments potentiels
            const potentialPanels = [
                ...document.querySelectorAll('[class*="navigation"]'),
                ...document.querySelectorAll('[class*="firstPerson"]'),
                ...document.querySelectorAll('[id*="navigation"]'),
                ...document.querySelectorAll('[id*="firstPerson"]'),
                ...document.querySelectorAll('[class*="panel"]'),
                ...document.querySelectorAll('[class*="control"]')
            ];

            console.log('üìã Found potential panels:', potentialPanels.length);

            potentialPanels.forEach((panel, index) => {
                console.log(`Panel ${index + 1}:`, {
                    tagName: panel.tagName,
                    className: panel.className,
                    id: panel.id,
                    display: panel.style.display,
                    visibility: panel.style.visibility,
                    textContent: panel.textContent ? panel.textContent.substring(0, 50) + '...' : 'No text'
                });
            });

            // Chercher sp√©cifiquement "Param√©trage"
            const allElements = document.querySelectorAll('*');
            let foundParametrage = false;
            allElements.forEach(element => {
                if (element.textContent && element.textContent.includes('Param√©trage')) {
                    foundParametrage = true;
                    console.log('üìã Found "Param√©trage" panel:', {
                        tagName: element.tagName,
                        className: element.className,
                        id: element.id,
                        display: element.style.display,
                        visibility: element.style.visibility
                    });
                }
            });

            if (!foundParametrage) {
                console.log('‚ùå No "Param√©trage" panel found - navigation panel may not be displayed');
            }

            return potentialPanels;
        };

        // Fonction pour forcer manuellement les vitesses First Person
        window.forceFirstPersonSpeed = function() {
            console.log('üîß Forcing First Person speeds manually...');

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    console.log('üìä Current speeds before manual change:');
                    console.log('  - panRate:', cameraControl.panRate);
                    console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                    console.log('  - dollyRate:', cameraControl.dollyRate);

                    // Forcer des vitesses tr√®s diff√©rentes pour test
                    cameraControl.panRate = 1.0;  // Tr√®s lent
                    cameraControl.keyboardPanRate = 0.3;  // Tr√®s lent
                    cameraControl.dollyRate = 0.5;  // Tr√®s lent
                    cameraControl.keyboardDollyRate = 0.3;  // Tr√®s lent
                    cameraControl.mouseWheelDollyRate = 2.0;  // Lent

                    console.log('üìä Speeds after manual change:');
                    console.log('  - panRate:', cameraControl.panRate);
                    console.log('  - keyboardPanRate:', cameraControl.keyboardPanRate);
                    console.log('  - dollyRate:', cameraControl.dollyRate);

                    console.log('‚úÖ Manual First Person speeds applied - navigation should be VERY slow now');
                } else {
                    console.error('‚ùå Camera control not found');
                }
            } catch (e) {
                console.error('‚ùå Error forcing speeds:', e);
            }
        };

        // Fonction pour forcer manuellement les vitesses normales
        window.forceNormalSpeed = function() {
            console.log('üîß Forcing Normal speeds manually...');

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    // Forcer des vitesses normales
                    cameraControl.panRate = 5.0;
                    cameraControl.keyboardPanRate = 1.0;
                    cameraControl.dollyRate = 2.0;
                    cameraControl.keyboardDollyRate = 1.0;
                    cameraControl.mouseWheelDollyRate = 10.0;

                    console.log('‚úÖ Manual Normal speeds applied - navigation should be normal speed now');
                } else {
                    console.error('‚ùå Camera control not found');
                }
            } catch (e) {
                console.error('‚ùå Error forcing speeds:', e);
            }
        };

        // Fonction pour tester la capture d'√©cran
        window.testScreenshotCapture = function() {
            console.log('üß™ Testing screenshot capture...');

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.scene) {
                    const camera = bimViewer.viewer.scene.camera;

                    console.log('üìç Current camera position before screenshot:');
                    console.log('  - Eye:', camera.eye);
                    console.log('  - Look:', camera.look);

                    // Prendre une capture
                    takeScreenshot();

                    // V√©rifier la position apr√®s un d√©lai
                    setTimeout(() => {
                        console.log('üìç Camera position after screenshot:');
                        console.log('  - Eye:', camera.eye);
                        console.log('  - Look:', camera.look);
                        console.log('‚úÖ Screenshot test completed - check if position changed');
                    }, 200);
                } else {
                    console.error('‚ùå BIM Viewer not ready for screenshot test');
                }
            } catch (e) {
                console.error('‚ùå Error testing screenshot:', e);
            }
        };

        // Fonction pour tester l'isolation des contr√¥les
        window.testControlsIsolation = function() {
            console.log('üß™ Testing controls isolation...');

            try {
                if (bimViewer && bimViewer.viewer && bimViewer.viewer.cameraControl) {
                    const cameraControl = bimViewer.viewer.cameraControl;

                    console.log('üìä Current control states:');
                    console.log('  - keyboardEnabled:', cameraControl.keyboardEnabled);
                    console.log('  - mouseEnabled:', cameraControl.mouseEnabled);
                    console.log('  - firstPersonMode (custom):', firstPersonMode);
                    console.log('  - firstPersonKeyStates:', firstPersonKeyStates);

                    if (cameraControl.firstPersonKeyboardEnabled !== undefined) {
                        console.log('  - firstPersonKeyboardEnabled:', cameraControl.firstPersonKeyboardEnabled);
                    }
                    if (cameraControl.firstPersonMouseEnabled !== undefined) {
                        console.log('  - firstPersonMouseEnabled:', cameraControl.firstPersonMouseEnabled);
                    }

                    console.log('üí° In First Person mode:');
                    console.log('  - Native keyboard should be: false');
                    console.log('  - Custom Z/S/D/Q should be: active');
                    console.log('  - Mouse look should be: enabled');
                } else {
                    console.error('‚ùå Camera control not found');
                }
            } catch (e) {
                console.error('‚ùå Error testing controls:', e);
            }
        };

        window.bimViewer = bimViewer;
    }
    // ===== DEBUG UTILS =====
window.debugExplorer = function() {
    console.group("Explorer Debug");
    const explorer = document.getElementById('myExplorer');
    console.log("Main element:", explorer);
    console.log("Computed style:", getComputedStyle(explorer));
    
    const treePanel = explorer.querySelector('.xeokit-tree-panel');
    console.log("Tree panel exists:", !!treePanel);
    if (treePanel) {
        console.log("Tree panel content:", treePanel.children.length > 0);
        console.log("Tree panel style:", getComputedStyle(treePanel));
    }
    
    console.log("Active tab:", bimViewer._currentTabId);
    console.groupEnd();
};



</script>

</html>